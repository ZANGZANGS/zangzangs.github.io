<?xml version="1.0" encoding="utf-8"?>

<feed xmlns="http://www.w3.org/2005/Atom" >
  <generator uri="https://jekyllrb.com/" version="3.7.4">Jekyll</generator>
  <link href="http://localhost:4000/tag/os/feed.xml" rel="self" type="application/atom+xml" />
  <link href="http://localhost:4000/" rel="alternate" type="text/html" />
  <updated>2021-04-04T19:45:07+09:00</updated>
  <id>http://localhost:4000/tag/os/feed.xml</id>

  
  
  

  
    <title type="html">장장스 블로그 | </title>
  

  
    <subtitle>Backend Developer</subtitle>
  

  

  
    
      
    
  

  
  

  
    <entry>
      <title type="html">(4) 프로세스 관리</title>
      <link href="http://localhost:4000/(4)-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EA%B4%80%EB%A6%AC" rel="alternate" type="text/html" title="(4) 프로세스 관리" />
      <published>2021-04-02T19:18:00+09:00</published>
      <updated>2021-04-02T19:18:00+09:00</updated>
      <id>http://localhost:4000/(4)%20%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%20%EA%B4%80%EB%A6%AC</id>
      <content type="html" xml:base="http://localhost:4000/(4)-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EA%B4%80%EB%A6%AC">&lt;hr /&gt;

&lt;h2 id=&quot;프로세스의-개념&quot;&gt;&lt;strong&gt;프로세스의 개념&lt;/strong&gt;&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Process is &lt;strong&gt;&lt;span style=&quot;color:red;&quot;&gt;a Programin execution &lt;/span&gt;&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;&lt;span style=&quot;color:red&quot;&gt;실행중인 프로그램&lt;/span&gt;&lt;/strong&gt; 을 프로세스라 한다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;프로세스의 문맥(context)
    &lt;blockquote&gt;
      &lt;p&gt;프로세스가 현재 &lt;strong&gt;어떤 상태&lt;/strong&gt;에서 수행되고 있는지 정확히 규명하기 위해 필요한 정보를 말한다.&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;프로세스 문맥은 크게 3가지로 &lt;strong&gt;하드웨어 문맥&lt;/strong&gt;, &lt;strong&gt;프로세스의 주소공간&lt;/strong&gt;, &lt;strong&gt;커널상의 문맥&lt;/strong&gt;으로 나누어 볼 수 있다.&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;CPU 수행 상태를 나타내는 &lt;strong&gt;하드웨어 문맥&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;Program Counter&lt;/li&gt;
          &lt;li&gt;각종 register&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;프로세스의 주소 공간&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;code, data, stack&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;프로세스 관련 &lt;strong&gt;커널&lt;/strong&gt; 자료 구조
        &lt;ul&gt;
          &lt;li&gt;PCB (Process Control Block)&lt;/li&gt;
          &lt;li&gt;Kernel stack (커널내의 주소)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;h2 id=&quot;프로세스의-상태&quot;&gt;&lt;strong&gt;프로세스의 상태&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;프로세스의 상태는 실행(running), 준비(ready), 봉쇄(blocked, wait, sleep)의 세 가지로 구분할 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;실행(Running)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;프로세스가 CPU를 잡고 기계어 instruction을 수행중인 상태를 말한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;준비(Ready)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;CPU만 보유하면 당장 명령을 수행 할 수 있도록 CPU를 기다리는 상태(메모리 등 다른 조건을 모두 만족)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;봉쇄(blocked, wait, sleep)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;CPU를 할당받더라도 당장 명령을 실행할 수 없는 상태를 말한다.
        &lt;ul&gt;
          &lt;li&gt;I/O 등의 event를 (스스로) 기다리는 상태&lt;/li&gt;
          &lt;li&gt;디스크에서 file을 읽어와야 하는 경우&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;시작 상태
    &lt;ul&gt;
      &lt;li&gt;프로세스가 시작되어 그 프로세스를 위한 각종 자료구조는 생성되었지만 아직 메모리 획득을 승인받지 못한 상태&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;완료 상태
    &lt;ul&gt;
      &lt;li&gt;프로세스가 종료되었으나 운영체제가 그 프로세스와 관련된 자료구조를 완전히 정리하지 못한 상태&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;​	&lt;strong&gt;Suspended (stoped)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;외부적인 이유로 프로세스의 수행이 정지된 상태&lt;/li&gt;
      &lt;li&gt;프로세스는 통째로 디스크에 swap out 된다&lt;/li&gt;
      &lt;li&gt;ex) 사용자 프로그램을 일시 정지시킨 경우 (break key) 시스템이 여러 이유로 프로세스를 잠시 중단시킴(메모리에 너무 많은 프로세스가 올라와 있을 때)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;Blocked: 자신이 요청한 event가 만족되면 Ready&lt;/li&gt;
    &lt;li&gt;Suspended: 외부에서 resume해 주어야 Active&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;center&gt;
  &lt;img src=&quot;/assets/images/operating_system/chap05_프로세스의 상태 변화도.png&quot; style=&quot;zoom:70%&quot; /&gt;
  프로세스의 상태 변화도
&lt;/center&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;h2 id=&quot;process-control-block-pcb&quot;&gt;Process Control Block (PCB)&lt;/h2&gt;
&lt;p&gt;프로세스 제어블록이란 운영체제가 시스템 내의 프로세스들을 관리하기 위해 프로세스마다 유지하는 정보들을 담는 커널 내의 자료구조를 말한다.&lt;/p&gt;

&lt;center&gt;
  &lt;img src=&quot;/assets/images/operating_system/ch05_PCB구성.png&quot; style=&quot;zoom:50%&quot; /&gt;
  프로세스 제어블록(PCB)의 구성
&lt;/center&gt;

&lt;!-- 
- 다음의 구성요소를 가진다 (구조체로 유지)
  1. OS 관리상 사용하는 정보  
     - 프로세스 상태(Process state), Process ID  
     - 스케쥴링 정보(scheduling information), 우선순위(priority)  
  2. CPU 수행 관련 하드웨어 값  
     - Program counter  
     - registers(현 시점에 레지스터에 어떤 값을 저장하고 있는지)  
  3. 메모리 관련  
     - code, data, stack 의 위치정보  
  4. 파일 관련  
     - Open file descriptors
--&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;h2 id=&quot;문맥-교환-context-switch&quot;&gt;&lt;strong&gt;문맥 교환 (Context Switch)&lt;/strong&gt;&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;한 프로세스에서 다른 프로세스로 CPU의 제어권을 넘겨주는 과정&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;CPU가 다른 프로세스에게 넘어갈 때 운영체제는 다음을 수행한다.
    &lt;ol&gt;
      &lt;li&gt;CPU를 내어주는 프로세스의 문맥(context)를 그 프로세스의 PCB에 저장&lt;/li&gt;
      &lt;li&gt;CPU를 새롭게 얻는 프로세스의 문맥(context)을 PCB로부터 읽어 실제 하드웨어로 복원&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;문맥교환이 아닌 것과 혼동하지 말자. 문맥교환은 프로세스A에서 프로세스B로 넘어가는것&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;System call이나 interrupt 발생시 반드시 context switch가 일어나는 것은 아니다
    &lt;ol&gt;
      &lt;li&gt;&lt;strong&gt;문맥교환 &lt;span style=&quot;color:red&quot;&gt;X&lt;/span&gt;&lt;/strong&gt;
 사용자 프로세스 A -&amp;gt; interrupt or system call -&amp;gt; 커널모드) -&amp;gt; &lt;strong&gt;&lt;span style=&quot;color:red&quot;&gt;문맥 교환 없이 user 모드 복귀&lt;/span&gt;&lt;/strong&gt; -&amp;gt; 사용자 프로세스 A&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;문맥교환 &lt;span style=&quot;color:blue&quot;&gt;O&lt;/span&gt;&lt;/strong&gt;
 사용자 프로세스 A -&amp;gt; interrupt or I/O 요청 system call  -&amp;gt; 커널모드(ISR or system call) -&amp;gt; &lt;strong&gt;&lt;span style=&quot;color:blue&quot;&gt;문맥 교환 발생&lt;/span&gt;&lt;/strong&gt; -&amp;gt; 사용자 프로세스 B&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;(1)의 경우에도 CPU 수행 정보 등 context의 일부를 PCB에 save해야 하지만 문맥교환을 하는 (2)의 경우 그 부담이 훨씬 크다. (eg. cache memory flush)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;h2 id=&quot;프로세스를-스케줄링하기-위한-큐&quot;&gt;&lt;strong&gt;프로세스를 스케줄링하기 위한 큐&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;운영체제는 하드웨어와 소프트웨어 자원을 줄세우기 위해 여러 Queue를 두어 사용한다. 프로세스들은 각 Queue들을 오가며 수행된다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Job queue&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;현재 시스템 내에 있는 모든 프로세스의 집합&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Ready queue&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;현재 메모리 내에 있으면서 CPU를 잡아서 실행되기를 기다리는 프로세스의 집합&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Device queues&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;I/O device의 처리를 기다리는 프로세스의 집합&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;h2 id=&quot;스케줄러-scheduler&quot;&gt;&lt;strong&gt;스케줄러 (Scheduler)&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;스케줄러란 어떤 프로세스에게 자원을 할당할지를 결정하는 운영체제 커널의 코드를 지칭한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;long-term-scheduler장기-스케줄러-or-job-scheduler&quot;&gt;&lt;strong&gt;Long-term scheduler(장기 스케줄러 or job scheduler)&lt;/strong&gt;&lt;/h4&gt;
    &lt;ul&gt;
      &lt;li&gt;시작 프로세스 중 어떤 것들을 &lt;strong&gt;ready queue&lt;/strong&gt;로 보낼지 결정&lt;/li&gt;
      &lt;li&gt;프로세스에 memory(및 각종 자원)을 주는 문제&lt;/li&gt;
      &lt;li&gt;degree of Multiprogramming을 제어&lt;/li&gt;
      &lt;li&gt;time sharing system에는 보통 장기 스케줄러가 없음(무조건 ready)&lt;/li&gt;
    &lt;/ul&gt;

    &lt;blockquote&gt;
      &lt;ul&gt;
        &lt;li&gt;프로세스 상태도에서 admitted 해주는게 장기스케줄러의 역할&lt;/li&gt;
        &lt;li&gt;&lt;em&gt;현대의 운영체제(시분할 시스템)는 하드웨어의 발전으로 장기 스케줄러 사용하지 않음&lt;/em&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;short-term-scheduler단기-스케줄러-or-cpu-scheduler&quot;&gt;&lt;strong&gt;Short-term scheduler(단기 스케줄러 or CPU scheduler)&lt;/strong&gt;&lt;/h4&gt;
    &lt;ul&gt;
      &lt;li&gt;ready queue에 있는 프로세스들 중 다음번에 running 시킬 프로세스를 결정&lt;/li&gt;
      &lt;li&gt;프로세스에 CPU를 할당하는 역할&lt;/li&gt;
      &lt;li&gt;매우 빈번하게 호출되므로 빨라야 한다 (millisecond 단위)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;medium-term-scheduler중기-스케줄러-or-swapper&quot;&gt;&lt;strong&gt;Medium-Term Scheduler(중기 스케줄러 or Swapper)&lt;/strong&gt;&lt;/h4&gt;
    &lt;blockquote&gt;
      &lt;p&gt;현대의 운영체제(시분할 시스템)에서 장기 스케줄러 사용이 낮아지면서 중기 스케줄러를 사용&lt;/p&gt;
    &lt;/blockquote&gt;
    &lt;ul&gt;
      &lt;li&gt;많은 프로세스에게 메모리를 할당해 시스템의 성능이 저하되는 일을 조절한다
        &lt;ul&gt;
          &lt;li&gt;프로세스에게서 메모리를 빼앗음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;여유 공간 마련을 위해 프로세스를 통째로 메모리에서 디스크의 swap 영역으로 저장함 &lt;strong&gt;(swap out)&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;봉쇄(block) 상태에 있는 프로세스가 0순위로 swap out&lt;/li&gt;
          &lt;li&gt;그래도 부족하면 타이머 인터럽트로 ready queue로 이동하는 프로세스를 추가적으로 swap out&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;degree of Multiprogramming을 제어&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;center&gt;
  &lt;img src=&quot;/assets/images/operating_system/chap05_프로세스 상태 변화도(중지 상태 포함).png&quot; style=&quot;zoom:90%&quot; /&gt;
  중지 상태를 포함한 프로세스의 상태 변화도
&lt;/center&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;!-- ## Thread (쓰레드)

&gt; **A &lt;span style=&quot;color:red&quot;&gt;thread&lt;/span&gt; (or &lt;span style=&quot;color:red&quot;&gt;lightweight process&lt;/span&gt;) is a basic unit of CPU utilization**

- Thread의 구성
  - program counter
  - register set
  - stack space
- Thread가 동료 Thread와 공유하는 부분(=task)
  - code section
  - data section
  - OS resources
- 전통적인 개념의 heavyweight process는 하나의 thread를 가지고 있는 task로 볼 수 있다
- 다중 스레드로 구성된 테스크 구조에서는 하나의 서버 스레드가 blocked (waiting) 상태인 동안에도 동일한 태스크 내의 다른 스레드가 실행(running)되어 빠른 처리를 할 수 있다.
- 동일한 일을 수행하는 다중 스레드가 협력하여 높은 처리율(throughput)과 성능 향상을 얻을 수 있다
- 스레드를 사용하면 병렬성을 높일 수 있다



### Benefits of Threads

- Responsiveness
  - 동시 처리로 빠른 응답성을 제공한다.
- Resource Sharing
  -  프로세스의 리소스인 code, data를 n개의 쓰레드가 공유할 수 있다.(stack 제외)
- Economy
  - creating &amp; CPU switching thread (rather than a process)
  - Solaris의 경우 위 두 가지 overhead가 각각 30배, 5배
- Utilization of MP Architectures
  - 멀티 프로세서 아키텍처의 사용에서 각각의 쓰레드를 다른 프로세서에서 병렬로 실행한다.

&lt;br&gt;

### Implementation of Threads

- Kernel Threads 

  &gt; Some are supported by kernel  
  &gt;
  &gt; 운영체제 커널이 지원하는 Threads 

  - Windows
  - Solaris
  - Digital UNIX, Mach

- User Threads

  &gt; Others are Supported by library
  &gt;
  &gt; 사용자가 에서 Threads를 관리

  - POSIX Pthreads
  - Mach C-threads
  - Solaris threds

- Some are real-time threads 

&lt;br&gt;&lt;hr&gt;--&gt;

&lt;h2 id=&quot;프로세스-생성&quot;&gt;&lt;strong&gt;프로세스 생성&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;시스템이 부팅된 후 최초의 프로세스는 운영체제가 직접 생성하지만 그다음부터는 이미 존재하는 프로세스가 다른 프로세스를 복제 생성하게 된다. 이때 프로세스를 생성한 프로세스를  &lt;strong&gt;&lt;span style=&quot;color:blue&quot;&gt;부모 프로세스(parent process)&lt;/span&gt;&lt;/strong&gt; 라고 하고 새롭게 생성된 프로세스를  &lt;strong&gt;&lt;span style=&quot;color:blue&quot;&gt; 자식 프로세스(children process)&lt;/span&gt;&lt;/strong&gt; 라고 한다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;부모 프로세스(parent process)&lt;/strong&gt; 가 &lt;strong&gt;자식 프로세스(children process)&lt;/strong&gt; 생성&lt;/li&gt;
  &lt;li&gt;프로세스의 트리(계층 구조) 형성&lt;/li&gt;
  &lt;li&gt;프로세스는 자원을 필요로함
    &lt;ul&gt;
      &lt;li&gt;운영체제로부터 받는다&lt;/li&gt;
      &lt;li&gt;부모와 공유한다
        &lt;ul&gt;
          &lt;li&gt;자원의 공유
            &lt;ul&gt;
              &lt;li&gt;부모와 자식이 모든 자원을 공유하는 모델&lt;/li&gt;
              &lt;li&gt;일부를 공유하는 모델&lt;/li&gt;
              &lt;li&gt;전혀 공유하지 않는 모델&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;수행 (Execution)
    &lt;ul&gt;
      &lt;li&gt;부모와 자식은 공존하며 수행되는 모델&lt;/li&gt;
      &lt;li&gt;자식이 종료(terminate)될 때까지 부모가 기다리는(wait) 모델&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;주소 공간 (Address space)
    &lt;ul&gt;
      &lt;li&gt;자식은 부모의 공간을 복사함 (binary and OS data)&lt;/li&gt;
      &lt;li&gt;자식은 부모의 공간을 복사함 (binary and OS data)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;유닉스의 예
    &lt;ul&gt;
      &lt;li&gt;&lt;span style=&quot;color:red&quot;&gt;fork()&lt;/span&gt; 시스템 콜이 새로운 프로세스를 생성
        &lt;ul&gt;
          &lt;li&gt;부모를 그대로 복사 (OS data except PID + binary)&lt;/li&gt;
          &lt;li&gt;주소 공간 할당&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;fork 다음에 이어지는 &lt;span style=&quot;color:red&quot;&gt;exec()&lt;/span&gt; 시스템 콜을 통해 새로운 프로그램을 메모리에 올림&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;프로세스가 마지막 명령을 수행한 후 운영체제에게 이를 알려줌(&lt;span style=&quot;color:red&quot;&gt;exit&lt;/span&gt;)
    &lt;ul&gt;
      &lt;li&gt;자식이 부모에게 output data를 보냄 (via &lt;span style=&quot;color:red&quot;&gt;wait&lt;/span&gt;)&lt;/li&gt;
      &lt;li&gt;프로세스의 각종 자원들이 운영체제에게 반납됨&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;부모 프로세스가 자식의 수행을 종료시킴 (&lt;span style=&quot;color:red&quot;&gt;abort&lt;/span&gt;)
    &lt;ul&gt;
      &lt;li&gt;자식이 할당 자원의 한계치를 넘어섬&lt;/li&gt;
      &lt;li&gt;자식에게 할당된 태스크가 더 이상 필요하지 않음&lt;/li&gt;
      &lt;li&gt;부모가 종료(exit)하는 경우
        &lt;ul&gt;
          &lt;li&gt;운영체제는 부모 프로세스가 종료하는 경우 자식 프로세스가 더 이상 수행되도록 두지 않는다(종료해버림)&lt;/li&gt;
          &lt;li&gt;프로세스의 계층 구조(트리)에 따라 단계적인 종료가 됨&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;프로세스-생성-절차&quot;&gt;프로세스 생성 절차&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Fork() 시스템 콜&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;프로세스 ID를 제외한 모든 내용을 그대로 복제 생성한다.&lt;/li&gt;
      &lt;li&gt;부모와 자식 프로세스는 서로 다른 주소공간을 갖는다.(주소공간 내용은 동일)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;exec() 시스템 콜&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;하나의 프로세스를 완전히 새로운 프로세스로 덮어쓰는 명령&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;wait() 시스템 콜&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;자식 프로세스가 종료되기를 기다리며 부모 프로세스가 봉쇄 상태에 머무르도록 할 때 사용된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;exit() 시스템 콜&lt;/strong&gt;
프로세스의 종료 종료하는 명령이다. 종료 명령은 자발적 종료와 비자발적 종료로 구분 된다.
    &lt;ul&gt;
      &lt;li&gt;자발적 종료
        &lt;ul&gt;
          &lt;li&gt;마지막 statement 수행 후 exit() 시스템 콜&lt;/li&gt;
          &lt;li&gt;프로그램에 명시적으로 적어주지 않아도 main함수가 리턴되는 위치에 컴파일러가 넣어줌&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;비자발적 종료
        &lt;ol&gt;
          &lt;li&gt;자식 프로세스가 한계치를 넘어서는 자원 요청하는 경우&lt;/li&gt;
          &lt;li&gt;자식에게 할당된 작업이 더 이상 필요하지 않는 경우&lt;/li&gt;
          &lt;li&gt;부모 프로세스가 종료되는 경우&lt;/li&gt;
          &lt;li&gt;키보드로 kill, break 등을 친 경우&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;hr /&gt;

&lt;h2 id=&quot;프로세스-간-협력&quot;&gt;&lt;strong&gt;프로세스 간 협력&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;원칙적으로 프로세스는 각자 자신만의 독립적인 주소 공간을 가지기 때문에 &lt;em&gt;다른 프로세스의 주소 공간을 참조하는 것은 허용되지 않는다.&lt;/em&gt; 그러나 경우에 따라서 &lt;em&gt;프로세스들 간의 협력이 효율을 증가시키는 점에서 더 생산적일 수 있다.&lt;/em&gt; 따라서 &lt;strong&gt;운영체제는 프로세스들간의 협력을 위한 매커니즘을 제공&lt;/strong&gt;한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;독립적 프로세스(Independent process)&lt;/strong&gt;
프로세스는 각자의 주소 공간을 가지고 수행되므로 원칙적으로 하나의 프로세스는 다른 프로세스의 수행에 영향을 미치지 못함&lt;/p&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;협력 프로세스(Cooperating process)&lt;/strong&gt;
프로세스 협력 메커니즘을 통해 하나의 프로세스가 다른 프로세스의 수행에 영향을 미칠 수 있음&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;프로세스-간-협력-메커니즘-ipc-interprocess-communication&quot;&gt;프로세스 간 협력 메커니즘 (IPC: Interprocess Communication)&lt;/h3&gt;

&lt;p&gt;IPC란 하나의 컴퓨터 안에서 실행 중인 서로 다른 프로세스 간에 발생하는 통신과 동기화를 이루기 위한 매커니즘을 말한다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;메시지를 전달하는 방법(Message passing)&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;프로세스 사이에 공유 변수(shared variable)를 일체 사용하지 않고 통신하는 시스템&lt;/li&gt;
      &lt;li&gt;커널을 통해 메시지를 주고 받음&lt;/li&gt;
      &lt;li&gt;커뮤니케이션 링크를 생성하고 send(), receive()&lt;/li&gt;
      &lt;li&gt;커뮤니케이션 링크 방법
        &lt;ol&gt;
          &lt;li&gt;Direct Communication
            &lt;ul&gt;
              &lt;li&gt;통신하려는 프로세스의 이름을 명시적으로 표시&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;Indirect Communication
            &lt;ul&gt;
              &lt;li&gt;mailbox (또는 port)를 통해 메시지를 간접 전달
&lt;br /&gt;&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;주소 공간을 공유하는 방법(Shared memory)&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;서로 다른 프로세스 간에 일부 주소 공간을 공유하게 하는 공유 메모리 매커니즘&lt;/li&gt;
      &lt;li&gt;같은 메모리 공간 사용으로 일관성 문제가 유발될 수 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;Thread는 사실상 하나의 프로세스이므로 프로세스 간 협력으로 보기는 어렵지만 동일한 프로세스를 구성하는 Threads들 간에는 주소 공간을 공유하므로 협력이 가능&lt;/p&gt;
&lt;/blockquote&gt;

&lt;center&gt;
  &lt;img src=&quot;/assets/images/operating_system/chap05_ipc.png&quot; style=&quot;zoom:90%&quot; /&gt;

  hared memory VS Message passing

&lt;/center&gt;

&lt;p&gt;&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>zangzangs</name>
        
        
      </author>

      

      
        <category term="os" />
      

      
        <summary type="html"></summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">(3) 프로그램의 구조와 실행</title>
      <link href="http://localhost:4000/(3)-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8%EC%9D%98-%EA%B5%AC%EC%A1%B0%EC%99%80-%EC%8B%A4%ED%96%89" rel="alternate" type="text/html" title="(3) 프로그램의 구조와 실행" />
      <published>2021-03-28T19:18:00+09:00</published>
      <updated>2021-03-28T19:18:00+09:00</updated>
      <id>http://localhost:4000/(3)%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8%EC%9D%98%20%EA%B5%AC%EC%A1%B0%EC%99%80%20%EC%8B%A4%ED%96%89</id>
      <content type="html" xml:base="http://localhost:4000/(3)-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8%EC%9D%98-%EA%B5%AC%EC%A1%B0%EC%99%80-%EC%8B%A4%ED%96%89">&lt;h2 id=&quot;프로그램의-실행&quot;&gt;프로그램의 실행&lt;/h2&gt;

&lt;p&gt;프로그램의 실행은 두가지 중요한 의미를 가진다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;파일 시스템에 존재하던 실행파일이 메모리에 적재된다는 의미&lt;/li&gt;
  &lt;li&gt;프로그램이 CPU를 할당받고 명령을 수행하고 있는 상태&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;파일 시스템에 있는 실행 파일이 메모리에 적재될 때, 실행파일 전체가 메모리에 올라가지 않는다. 일부분만 메모리에 올라가고 나머지는 디스크의 특정영역인 스왑 영역에 존재한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;가상-메모리-virtual-memory&quot;&gt;가상 메모리 (virtual memory)&lt;/h2&gt;

&lt;p&gt;프로세스의 주소 공간은 코드(code), 데이타(data), 스택(stack)영역으로 구성된다. 이러한 주소 공간을 우리는 가상 메모리 (또는 논리적 메모리: logical memory)라고 부른다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;code
    &lt;ul&gt;
      &lt;li&gt;사용자가 작성한 프로그램 함수들의 코드가 CPU에서 수행할 수 있는 기계어 명령 형태로 변환되어 저장되는 공간&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;data
    &lt;ul&gt;
      &lt;li&gt;전역 변수 등 프로그램이 사용하는 데이터를 저장하는 공간&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;stack
    &lt;ul&gt;
      &lt;li&gt;호출된 함수의 수행을 마치고 복귀할 주소 및 데이터를 임시로 저장하는 공간&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;커널-주소-공간의-내용&quot;&gt;커널 주소 공간의 내용&lt;/h2&gt;

&lt;p&gt;운영체제도 하나의 프로세스이기 때문에 커널 역시 동일한 주소 공간인 code, data, stack 영역을 갖는다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;code&quot;&gt;code&lt;/h4&gt;
    &lt;ul&gt;
      &lt;li&gt;시스템 콜, 인터럽트 처리 코드&lt;/li&gt;
      &lt;li&gt;CPU, 메모리 등 자원 관리를 위한 코드&lt;/li&gt;
      &lt;li&gt;편리한 인터페이스 제공을 위한 코드&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;data&quot;&gt;data&lt;/h4&gt;
    &lt;ul&gt;
      &lt;li&gt;PCB(Process Controll Block)
        &lt;ul&gt;
          &lt;li&gt;현재 수행 중인 프로세스의 상태, CPU 사용 정보 등을 유지하기 위한 자료구조&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;CPU, Memory 등 하드웨어 자원을 관리하기 위한 자료구조가 저장&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;stack&quot;&gt;stack&lt;/h4&gt;
    &lt;ul&gt;
      &lt;li&gt;각 Process의 커널 스택을 저장
        &lt;ul&gt;
          &lt;li&gt;프로세스는 함수 호출시 자신의 복귀 주소를 저장하지만, 커널은 커널 내의 주소가 된다.&lt;/li&gt;
          &lt;li&gt;각각의 프로세스마다 별도의 스택을 두어 관리한다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;사용자-프로그램이-사용하는-함수&quot;&gt;사용자 프로그램이 사용하는 함수&lt;/h2&gt;
&lt;p&gt;함수는 크게 두가지로 나눌 수 있다. 프로세스 함수와 커널함수&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;사용자 정의 함수(프로세스 함수)
    &lt;ul&gt;
      &lt;li&gt;자신의 프로그램에서 정의한 함수&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;라이브러리 함수(프로세스 함수)
    &lt;ul&gt;
      &lt;li&gt;자신의 프로그램에서 정의하지 않고 갖다 쓴 함수&lt;/li&gt;
      &lt;li&gt;자신의 프로그램의 실행 파일에 포함되어 있다.&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;커널 함수
    &lt;ul&gt;
      &lt;li&gt;운영체제 프로그램의 함수&lt;/li&gt;
      &lt;li&gt;커널 함수의 호출 = 시스템 콜&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;인터럽트&quot;&gt;인터럽트&lt;/h2&gt;

&lt;p&gt;CPU는 매번 프로그램 카운터가 가리키고 있는 지점의 명령을 하나씩 수행하고 나서, 다음 명령을 수행하기 직전에 인터럽트 라인이 세팅되었는지 체크한다. 인터럽트 라인 체크를 통해 인터럽트가 발생했으면 CPU는 현재 수행하던 프로세스를 멈추고 운영체제의 인터럽트 처리 루틴으로 이동해서 인터럽트 처리를 수행한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;그렇다면 인터럽트 처리중에 또다른 인터럽트가 발생하는 경우는 어떻게 되는가?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;원직적으로는 인터럽트 처리중에 또 다른 인터럽트의 처리를 허용하지 않는다.
    &lt;ul&gt;
      &lt;li&gt;앞서 변경중이던 데이터를 또다른 인터럽트가 발생해 처리하게 되면 의도하지 않은 결과값으로 바뀔 수 있기 때문이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;예외적인 경우가 존재한다.
    &lt;ul&gt;
      &lt;li&gt;인터럽트마다 중요도가 다르다.&lt;/li&gt;
      &lt;li&gt;상대적으로 낮은 중요도를 가진 인터럽트를 처리하는 도중 높은 중요도의 인터럽트 발생을 허용한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;프로세스의-두-가지-실행-상태&quot;&gt;프로세스의 두 가지 실행 상태&lt;/h2&gt;
&lt;p&gt;mode bit에 따라 user mode, kernel mode를 반복하며 실행된다. 프로그램이 시작되어 종료될 때까지 다양한 함수 호출을 하며 실행되는데, 이를 사용자 모드와 커널모드의 실행 상태로 구분 지을 수 있다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;사용자 모드(user mode)
    &lt;ul&gt;
      &lt;li&gt;프로그램이 사용자 정의함수나 라이브러리 함수를 호출&lt;/li&gt;
      &lt;li&gt;시스템 콜의 실행이 끝나고 시스템 콜 이후의 명령을 수행하는 경우&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;커널 모드(kernel mode)
    &lt;ul&gt;
      &lt;li&gt;시스템 콜을 하는 경우&lt;/li&gt;
      &lt;li&gt;프로그램의 실행이 끝날 때 커널모드로 진입하여 프로그램을 종료함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>zangzangs</name>
        
        
      </author>

      

      
        <category term="os" />
      

      
        <summary type="html">프로그램의 실행</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">(2) 컴퓨터 시스템의 동작 원리</title>
      <link href="http://localhost:4000/(2)-%EC%BB%B4%ED%93%A8%ED%84%B0-%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%98-%EB%8F%99%EC%9E%91-%EC%9B%90%EB%A6%AC" rel="alternate" type="text/html" title="(2) 컴퓨터 시스템의 동작 원리" />
      <published>2021-03-21T19:18:00+09:00</published>
      <updated>2021-03-21T19:18:00+09:00</updated>
      <id>http://localhost:4000/(2)%20%EC%BB%B4%ED%93%A8%ED%84%B0%20%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%98%20%EB%8F%99%EC%9E%91%20%EC%9B%90%EB%A6%AC</id>
      <content type="html" xml:base="http://localhost:4000/(2)-%EC%BB%B4%ED%93%A8%ED%84%B0-%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%98-%EB%8F%99%EC%9E%91-%EC%9B%90%EB%A6%AC">&lt;h2 id=&quot;컴퓨터-시스템-구조&quot;&gt;컴퓨터 시스템 구조&lt;/h2&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;center&gt;
&lt;img src=&quot;../..\assets\images\operating_system\chap03_computer_system_structure.png&quot; style=&quot;zoom:60%&quot; /&gt;

&lt;span style=&quot;color:gray; size:10&quot;&gt;&lt;컴퓨터 시스템=&quot;&quot; 구조=&quot;&quot;&gt;&amp;lt;/span&amp;gt;
&amp;lt;/center&amp;gt;

---

### 1. CPU
중앙처리장치라 불리는 CPU는 인간의 **두뇌**와 같은 역할을 합니다. **중앙처리장치** 라는 말 그대로 중앙에서 사용자가 입력한 명령어를 해석하고 연산한 후 그 결과를 처리합니다.

&lt;br /&gt;

### 2. 메모리
 랜덤 액세스 메모리 즉, 램(RAM)은 임의의 영역에 접근하여 읽고 쓰기가 가능한 주기억 장치다. RAM은 어느 위치에 저장된 데이터든지 접근(읽기 및 쓰기)하는 데 동일한 시간이 걸리는 메모리이기에 ‘랜덤(Random, 무작위)’이라는 명칭이 주어진다. 
 
&lt;br /&gt;

### 3. Device Controller
- I/O device controller
  - 해당 I/O 장치 유형을 관리하는 일종의 작은 CPU
  - 제어 정보를 위해 control register, status register가 있다.
  - local buffer를 갖는다 (=일종의 data register)
- I/O는 실제 device와 local buffer 사이에서 일어남
- Device controller는 I/O가 끝났을 경우 interrupt로 CPU에 그 사실을 알림

&amp;gt; device driver(장치구동기)  
&amp;gt; : os 코드 중 각 장치별 처리루틴 -&amp;gt; software  
&amp;gt; device controller(장치제어기)  
&amp;gt; : 각 장치를 통제하는 일종의 작은 cpu -&amp;gt; hardware

&lt;br /&gt;

### 4. Interrupt line
CPU로 인터럽트 신호를 보낼 수 있는 하드웨어 라인

&lt;br /&gt;

### 5. Mode bit
사용자 프로그램의 잘못된 수행으로 다른 프로그램 및 운영체제에 피해가 가지 않도록 하기 위한 보호장치가 필요
Mode bit을 통해 하드웨어적으로 두 가지 모드의 operation 지원

&amp;gt; 1 &lt;span style=&quot;color:blue&quot;&gt;사용자 모드&lt;/span&gt; : 사용자 프로그램 수행  
&amp;gt; 0 &lt;span style=&quot;color:red&quot;&gt;모니터 모드&lt;/span&gt; : OS 코드 수행 (=커널 모드, 시스템 모드)  

- 보안을 해칠 수 있는 중요한 명령어는 모니터 모드에서만 수행 가능한 **'특권명령'** 으로 규정
- Interrupt나 Exception 발생시 하드웨어가 mode bit을 0으로 변경
- 사용자 프로그램에게 CPU를 넘기기 전에 mode bit을 1로 변경

&lt;br /&gt;

### 6. Timer
- 타이머
  - 정해진 시간이 흐른 뒤 운영체제에게 제어권이 넘어가도록 인터럽트를 발생
  - 타이머는 매 클럭 틱 때마다 1씩 감소
  - 타이머 값이 -이 되면 타이머 인터럽트 발생
  - CPU를 특정 프로그램이 독점하는 것으로부터 보호
  
- 타이머는 time sharing을 구현하기 위해 널리 이용됨
- 타이머는 현재 시간을 계산하기 위해서도 사용

&lt;br /&gt;

### 7. DMA Controller

메모리에 접근할 수 있는 장치는 CPU가 유일하다. 메모리는 CPU의 작업 공간이다. I/O장치나 다른 장치들이 접근 할 수 없다. 그렇다보니 1ms 마다 인터럽트가 발생한다면 CPU는 계속해서 자잘한 인터럽트를 처리해야하는 이슈가 있다. 그래서 메모리에 접근 할 수 있도록 도와주는 장치가 DMA 컨트롤러이다. 

- 빠른 입출력 장치를 메모리에 가까운 속도로 처리하기 위해 사용
- CPU의 중재 없이 device controller가 device의 buffer storage의 내용을 메모리에 block 단위로 직접 전손
- 바이트 단위가 아니라 block 단위로 인터럽트를 발생시킴
- 
&lt;br /&gt;

### 8. PC(Program counter)
CPU의 레지스터중 하나.
pc는 다음번에 실행할 명령어의 주소를 가지고 있다.
하나의 기계어가 종료 이후의 다음 위치를 가리킨다.

&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;

---

## 인터럽트(Interrupt)
### 인터럽트
- 현대의 운영체제는 인터럽트에 의해 구동된다.
- 인터럽트 당한 시점의 레지스터와 Program counter를 save 한 후 CPU의 제어를 인터럽트 처리 루틴에 넘긴다.

&lt;br /&gt;

### 넓은 의미의 interrupt
- 하드웨어 인터럽트
  - 하드웨어가 발생시킨 인터럽트
- 소프트웨어 인터럽트  
    - Exception : 프로그램이 오류를 범한 경우
    - Systeme Call : 프로그램이 커널 함수를 호출하는 경우

&lt;br /&gt;

### 인터럽트 관련 용어
- 인터럽트 백터  
  해당 인터럽트 처리 루틴 주소를 가지고 있음
- 인터럽트 처리 루틴(=Interrupt Service Routine, 인터럽트 핸들러)  
  해당 인터럽트를 처리하는 커널 함수

### 동작
1. 인터럽트가 발생하면 CPU는 하던 일을 멈추고 커널 내에서 해당 인터럽트의 처리를 위해 정의된 코드를 찾게된다.  
2. 운영체제는 할 일을 쉽게 찾아가기 위해 인터럽트 벡터(interrupt vector)를 가지고 있다. 인터럽트 백터란 인터럽트 종류마다 번호를 정해서 번호에 따라 처리해야 할 코드가 위치한 부분을 가리키는 자료구조를 말한다.  
3. 인터럽트 백터를 따라가면 실제 처리해야 할 코드는 인터럽트 처리 루틴(Interrupt service routine) 또는 인터럽트 핸들러(Interrupt handler)라고 불리는 다른 곳에 정의된다.  
 4. 인터럽트 처리 루틴을 통해 해당되는 인터럽트 처리를 완료하고 나면 원래 수행하던 작업으로 돌아가 중단되었던 일을 계속해서 수행한다.  

&lt;br /&gt;

 ### 시스템 콜(System Call)
사용자 프로그램이 운영체제의 서비스를 받기 위해 커널함수(운영체제)를 호출하는 것


&lt;br /&gt;

&amp;gt; 질문: 운영체제한테 CPU가 넘어가는 경우  
&amp;gt; - 인터럽트 발생(Interrupt Line 사용하는 경우)  
&amp;gt;   - 하드웨어 장치들이 I/O가 인터럽트를 요청 할 때  
&amp;gt;   - timer 가 정해진 시간이 지난 후에 CPU에 제어권을 넘긴다.  
&amp;gt;   - 시스템 콜 발생시
&amp;gt; - Exception 발생시




 &lt;br /&gt;&lt;br /&gt;&lt;br /&gt;

---

## 동기식 입출력과 비동기식 입출력

- 동기식 입출력(synchronous I/O)
  - I/O 요청 후 입출력 작업이 완료된 후에야 제어가 사용자 프로그램에 넘어감
  - 구현 방법1
    - I/O가 끝날 때까지 CPU를 낭비시킴
    - 매시점 하나의 I/O만 일어날 수 있음
  - 구현 방법2
    - I/O가 완료될 때까지 해당 프로그램에게서 CPU를 빼앗음
    - I/O 처리를 기다리는 줄에 그 프로그램을 줄 세움
    - 다른 프로그램에게 CPU를 줌

- 비동기식 입출력(asynchronous I/O)
  - I/O가 시작된 후 입출력 작업이 끝나기를 기다리지 않고 제어가 사용자 프로그램에 즉시 넘어감

&amp;gt; 두 경우 모두 I/O 완료는 인터럽트로 알려준다.

&lt;br /&gt;
&lt;/컴퓨터&gt;&lt;/span&gt;&lt;/center&gt;</content>

      
      
      
      
      

      <author>
          <name>zangzangs</name>
        
        
      </author>

      

      
        <category term="os" />
      

      
        <summary type="html">컴퓨터 시스템 구조</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">(1) 운영체제 개요</title>
      <link href="http://localhost:4000/(1)-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EA%B0%9C%EC%9A%94" rel="alternate" type="text/html" title="(1) 운영체제 개요" />
      <published>2021-03-13T19:18:00+09:00</published>
      <updated>2021-03-13T19:18:00+09:00</updated>
      <id>http://localhost:4000/(1)%20%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%20%EA%B0%9C%EC%9A%94</id>
      <content type="html" xml:base="http://localhost:4000/(1)-%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EA%B0%9C%EC%9A%94">&lt;h2 id=&quot;운영체제의-정의&quot;&gt;운영체제의 정의&lt;/h2&gt;
&lt;p&gt;하드웨어 바로 위에 설치되어 사용자 및 다른 모든 소프트웨어와 하드웨어를 연결하는 소프트웨어 계층&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;center&gt;
&lt;img src=&quot;../../assets/images/operating_system/chap02_os.png&quot; style=&quot;zoom:67%;&quot; /&gt;
&lt;/center&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;운영체제의-기능&quot;&gt;운영체제의 기능&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;자원을 효율적으로 관리한다.
    &lt;ul&gt;
      &lt;li&gt;효율성: 효율적이나 일부가 지나치게 희생되지 않도록&lt;/li&gt;
      &lt;li&gt;형평성: 프로그램들 간의 자원을 형평성 있게 분배&lt;/li&gt;
      &lt;li&gt;보안 및 보호&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;사용자 및 운영체제 자신의 보호한다.&lt;/li&gt;
  &lt;li&gt;프로세스, 파일, 메시지 등을 관리한다.&lt;/li&gt;
  &lt;li&gt;컴퓨터 시스템을 편리하게 사용할 수 있는 환경을 제공한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;운영체제의-분류&quot;&gt;운영체제의 분류&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;동시 작업 가능 여부
    &lt;ul&gt;
      &lt;li&gt;단일작업(single tasking)&lt;/li&gt;
      &lt;li&gt;다중작업(multi tasking)&lt;span style=&quot;color:red&quot;&gt; ✓pick&lt;/span&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;사용자 수
    &lt;ul&gt;
      &lt;li&gt;단일 사용자&lt;/li&gt;
      &lt;li&gt;다중 사용자&lt;span style=&quot;color:red&quot;&gt; ✓pick&lt;/span&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;처리방식
    &lt;ul&gt;
      &lt;li&gt;일괄처리 방식(batch processing)&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;시분할 방식(time sharing system)&lt;/strong&gt;&lt;span style=&quot;color:red&quot;&gt; ✓pick&lt;/span&gt;&lt;/li&gt;
      &lt;li&gt;실시간(real time)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;운영-체제의-자원-관리-기능&quot;&gt;운영 체제의 자원 관리 기능&lt;/h2&gt;

&lt;h3 id=&quot;1-cpu-스케쥴링cpu-scheduling&quot;&gt;1. CPU 스케쥴링(CPU scheduling)&lt;/h3&gt;
&lt;p&gt;CPU를 가장 효율적으로 사용하면서도, 특정 프로세스가 불이익을 당하지 않도록 하는 것&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;선입선출
CPU를 사용하기 위해 도착한 프로세스들 중 먼저 온 것을 먼저 처리해주는 방식&lt;/li&gt;
  &lt;li&gt;라운드 로빈(Round Robin)&lt;span style=&quot;color:red&quot;&gt; ✓pick&lt;/span&gt;
CPU를 한 번 할당받아 사용할 수 있는 시간을 일정하게 고정된 시간으로 제한한다.&lt;/li&gt;
  &lt;li&gt;우선순위
대기 중인 프로세스들에 우선순위를 부여하고 우선순위가 높은 프로세스에 CPU를 먼저 할당한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;2-메모리-관리&quot;&gt;2. 메모리 관리&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;고정분할 방식(fixed partition)
    &lt;ul&gt;
      &lt;li&gt;물리적 메모리를 일정 개수로 분할 하여 사용하는 방식을 말한다.&lt;/li&gt;
      &lt;li&gt;단점으로 분할 개수만큼만 프로그램을 사용할 수 있으며, 분할된 메모리보다 큰 프로그램은 적재가 불가능하다.&lt;/li&gt;
      &lt;li&gt;분할된 메모리보다 적은 메모리를 사용하는 프로그램이 적재가 되면 남는 메모리영역이 발생하는데 이를 &lt;span style=&quot;color:blue&quot;&gt;내부조각(internal fragment)&lt;/span&gt; 이라고 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;가변분할 방식(variable partition)
    &lt;ul&gt;
      &lt;li&gt;프로그램 크기에 맞게 메모리를 분할해서 사용하는 방식을 말한다.&lt;/li&gt;
      &lt;li&gt;메모리가 일정부분 20이 남았다고 했을 때, 40의 메모리를 가진 프로그램을 적재할 수 없어 남는 메모리 영역이 발생한다. 이를 &lt;span style=&quot;color:blue&quot;&gt;외부조각(external fragment)&lt;/span&gt;이라고 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;가상메모리(virtual memory)&lt;span style=&quot;color:red&quot;&gt; ✓pick&lt;/span&gt;
    &lt;ul&gt;
      &lt;li&gt;물리적 메모리보다 더 큰 프로그램이 실행되는 것을 지원한다.&lt;/li&gt;
      &lt;li&gt;현재 사용되고 있는 부분만 메모리에 올리고, 나머지는 하드디스크와 같은 보조기억장치에 저장해두었다가 필요할 때 적재하는 방식을 취한다. 이떄 사용되는 보조기억장치의 영역을 &lt;span style=&quot;color:blue&quot;&gt;스왑 영역(swap area)&lt;/span&gt;이라고 부른다.&lt;/li&gt;
      &lt;li&gt;가상메모리 주소 공간은 페이지(page)라는 동일한 크기의 작은 단위로 나뉘어 물리적 메모리와 스왑 영역에 일부분씩 저장된다. 이렇게 동일한 단위로 메모리를 나누는 기업을 &lt;span style=&quot;color:blue&quot;&gt;페이징(paging) 기법&lt;/span&gt;이라고 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;3-주변장치-및-입출력-관리&quot;&gt;3. 주변장치 및 입출력 관리&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;인터럽트
    &lt;ul&gt;
      &lt;li&gt;주변장치들이 CPU의 서비스가 필요한 경우 보내는 신호&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;컨트롤러
    &lt;ul&gt;
      &lt;li&gt;주변장치들이 메인 CPU에 인터럽트를 발생시켜 보고하는 역할&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;br /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content>

      
      
      
      
      

      <author>
          <name>zangzangs</name>
        
        
      </author>

      

      
        <category term="os" />
      

      
        <summary type="html">운영체제의 정의 하드웨어 바로 위에 설치되어 사용자 및 다른 모든 소프트웨어와 하드웨어를 연결하는 소프트웨어 계층</summary>
      

      
      
    </entry>
  
</feed>
