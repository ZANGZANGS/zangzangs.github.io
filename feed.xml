<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.7.4">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2021-04-25T17:47:24+09:00</updated><id>http://localhost:4000/</id><title type="html">장장스 블로그</title><subtitle>Backend Developer</subtitle><entry><title type="html">(4) CPU 스케줄링</title><link href="http://localhost:4000/os05" rel="alternate" type="text/html" title="(4) CPU 스케줄링" /><published>2021-04-10T19:18:00+09:00</published><updated>2021-04-10T19:18:00+09:00</updated><id>http://localhost:4000/os05</id><content type="html" xml:base="http://localhost:4000/os05">&lt;p&gt;사용자 프로그램이 수행되는 과정은 &lt;strong&gt;CPU 작업과 I/O 작업의 반복&lt;/strong&gt;으로 수행된다.&lt;/p&gt;

&lt;p&gt;사용자 프로그램이 CPU를 직접 가지고 빠른 명령을 수행하는 일련의 단계를 &lt;strong&gt;CPU 버스트&lt;/strong&gt;라고 하고,
사용자 프로그램에 I/O 요청이 발생해 커널에 의해 입출력 작업을 진행하는 비교적 느린 &lt;strong&gt;I/O 버스트&lt;/strong&gt;라 한다.
사용자 프로그램은 사이클처럼 CPU 버스트와 I/O 버스트 작업이 번갈아 수행된다.&lt;/p&gt;

&lt;div style=&quot;text-align:center;&quot;&gt;
  &lt;img src=&quot;/assets/images/operating_system/chap06_burst.png&quot; style=&quot;zoom:110%&quot; /&gt;
&lt;/div&gt;

&lt;p&gt;모든 작업이 동일하다면 순서대로 처리하면 되겠지만, 실제 프로세스는 매우 다양한 작업이 섞여있다.
그렇다면 어떤 작업에 어떤 응답을 주어야 가장 효율이 높게 사용할 수 있을까?란 의문이 든다. 그래서 CPU 스케줄링이 필요하다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;CPU 스케줄링의 필요성
    &lt;ul&gt;
      &lt;li&gt;여러 종류의 job(=process)이 섞여 있기 때문에 스케줄링이 필요하다&lt;/li&gt;
      &lt;li&gt;interactive job에게 적절한 response 제공 요망&lt;/li&gt;
      &lt;li&gt;CPU와 I/O 장치 등 시스템 자원을 골고루 효율적으로 사용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;cpu-scheduler--dispatcher&quot;&gt;CPU Scheduler &amp;amp; Dispatcher&lt;/h2&gt;

&lt;h3 id=&quot;cpu-scheduler&quot;&gt;CPU Scheduler&lt;/h3&gt;
&lt;p&gt;준비 상태의 프로세스 중에서 이번에 CPU를 할당할 프로세스를 선택하는 코드&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;CPU 스케줄링이 필요한 상태 변화가 있는 경우 4가지
    &lt;ol&gt;
      &lt;li&gt;Running -&amp;gt; Blocked (ex: I/O 요청하는 시스템 콜 )&lt;/li&gt;
      &lt;li&gt;Running -&amp;gt; Ready (ex: 할당시간만료로 timer interrupt )&lt;/li&gt;
      &lt;li&gt;Blocked -&amp;gt; Ready (ex: I/O 완료후 인터럽트 )&lt;/li&gt;
      &lt;li&gt;Terminate&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;1,4  nonpreemptive (= 강제로 빼앗지 않고 자진 반납)
  이 외에는 preemptive(= 강제로 빼앗음)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;dispatcher&quot;&gt;Dispatcher&lt;/h3&gt;
&lt;p&gt;스케줄러에 의해 선택된 프로세스에게 CPU를 넘겨주고 작업을 수행할 수 있도록 하는 코드&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;PCB에 현재 프로세스의 상태를 저장한다.&lt;/li&gt;
  &lt;li&gt;새로 선택된 프로세스의 context의 PCB로부터 복원하고 CPU를 넘긴다&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이처럼 디스패처가 하나의 프로세스를 정지 시키고 다른 프로세스에게 CPU를 전달하기 까지 걸리는 시간을 &lt;strong&gt;dispatch latency&lt;/strong&gt; 라 한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;스케줄링의-성능-평가scheduling-criteria&quot;&gt;스케줄링의 성능 평가(Scheduling Criteria)&lt;/h2&gt;
&lt;p&gt;Performance Index (= Performance Measure, 성능 척도)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;CPU utilization(이용률)
    &lt;ul&gt;
      &lt;li&gt;keep the CPU as busy as possible&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Throughput(처리량)
    &lt;ul&gt;
      &lt;li&gt;
        &lt;h1 id=&quot;of-processes-that-complete-their-execution-per-time-unit&quot;&gt;of processes that complete their execution per time unit&lt;/h1&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Turnaround time (소요시간, 반환시간)
    &lt;ul&gt;
      &lt;li&gt;amount of time to execute a particular process&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Waiting time (대기 시간)
    &lt;ul&gt;
      &lt;li&gt;amount of time a process has been waiting in the ready queue&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Response tiem (응답 시간)
    &lt;ul&gt;
      &lt;li&gt;amount of time it takes from when a request was submitted until the first response is produced, not output (for time-sharing environment)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;cpu-스케줄링-알고리즘&quot;&gt;CPU 스케줄링 알고리즘&lt;/h2&gt;

&lt;h3 id=&quot;fcfs-first-come-first-served&quot;&gt;FCFS (First-Come First-Served)&lt;/h3&gt;

&lt;p&gt;먼저 도착한 프로세스 순서대로 처리&lt;/p&gt;

&lt;p&gt;콘보이 이펙트&lt;/p&gt;
&lt;h3 id=&quot;sjfshortest-job_first&quot;&gt;SJF(Shortest-Job_First)&lt;/h3&gt;
&lt;p&gt;가장 짧은 시간의 job을 먼저 처리&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;nonpreemptive
    &lt;ul&gt;
      &lt;li&gt;일단 CPU를 선점하면 종료까지 사용한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;preemptive
    &lt;ul&gt;
      &lt;li&gt;프로세스의 남은 사용 시간을 기준으로 처리한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;srtfshortest-remaining-time-first&quot;&gt;SRTF(Shortest-Remaining-Time-First)&lt;/h3&gt;

&lt;h3 id=&quot;priority-scheduling&quot;&gt;Priority Scheduling&lt;/h3&gt;

&lt;h3 id=&quot;round-robin라운드-로빈&quot;&gt;Round Robin(라운드 로빈)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;각 프로세스는 동일한 크기의 할당 시간을 가진다. (1~100ms)&lt;/li&gt;
  &lt;li&gt;할당 시간이 지나면 프로세스는 선점(preempted)당하고 ready queue의 제일 뒤에 가서 다시 줄을 선다&lt;/li&gt;
  &lt;li&gt;n 개의 프로세스가 ready queue에 있고 할당 시간이 q  time unit인 경우 각 프로세스는 최대 q time unit 단위로 CPU 시간의 1/n을 얻는다.
=&amp;gt; 어떤 프로세스도 (n-1)q time unit 이상 기다리지 않는다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;multilevel-queue&quot;&gt;Multilevel Queue&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Ready queue 를 여러 개로 분할
    &lt;ul&gt;
      &lt;li&gt;foreground(interactive)&lt;/li&gt;
      &lt;li&gt;background(batch - no human interactive)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;multilevel-feedback-queue&quot;&gt;Multilevel Feedback Queue&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;프로세스가 다른 큐로 이동 가능&lt;/li&gt;
  &lt;li&gt;에이징을 이와 같은 방식으로 구현할 수 있다.&lt;/li&gt;
  &lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;multiple-processor-scheduling&quot;&gt;Multiple-Processor Scheduling&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;CPU가 여러 개인 경우 스케줄링은 더욱 복잡해짐&lt;/li&gt;
  &lt;li&gt;Homogeneous processor인 경우
    &lt;ul&gt;
      &lt;li&gt;Queue에 한줄로 세워서 각 프로세서가 알아서 꺼내가게 할 수 있다.&lt;/li&gt;
      &lt;li&gt;반드시 틍정 프로세서에서 수행되어야 하는 프로세스가 있는 경우에는 문제가 더 복잡해짐&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Load sharing
    &lt;ul&gt;
      &lt;li&gt;일부 프로세서에 job이 몰리지 않도록 부하를 적절히 공유하는 메커니즘 필요&lt;/li&gt;
      &lt;li&gt;별개의 큐를 두는 방법 vs 공동 큐를 사용하는 방법&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Symmetric Multiprocessing(SMP)
    &lt;ul&gt;
      &lt;li&gt;각 프로세서가 각자 알아서 스케줄링 결정&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Asymmetric multiprocessing
    &lt;ul&gt;
      &lt;li&gt;하나의 프로세서가 시스템 데이터의 접근과 공유를 책임지고 나머지 프로세서는 거기에 따름
        &lt;blockquote&gt;
          &lt;blockquote&gt;
            &lt;p&gt;대장 CPU가 스케줄링함&lt;/p&gt;
          &lt;/blockquote&gt;
        &lt;/blockquote&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;real-time-scheduling&quot;&gt;Real-TIme Scheduling&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Hard real-time systems
    &lt;ul&gt;
      &lt;li&gt;정해진 시간 안에 반드시 끝내도록 스케줄링해야 함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Soft real-time computing
    &lt;ul&gt;
      &lt;li&gt;일반 프로세스에 비해 높은 우선순위를 갖도록 해야함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;thread-scheduling&quot;&gt;Thread Scheduling&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Local Scheduling
    &lt;ul&gt;
      &lt;li&gt;사용자 수준의 Thread 라이브러리에 의해 어떤 Thread를 스케줄할지 결정&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Global Scheduling
    &lt;ul&gt;
      &lt;li&gt;일반 프로세스와 마찬가지로 커널의 단기 스케줄러가 어떤 thread를 스케줄할지 결정&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;알고리즘-평가방법&quot;&gt;알고리즘 평가방법&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Queueing models
    &lt;ul&gt;
      &lt;li&gt;확률 분포로 주어지는 arrival rate와 sevice rate 등을 통해 각종 performance index 값을 계산&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Implementation(구현) &amp;amp; Measurement (성능 측정)
    &lt;ul&gt;
      &lt;li&gt;실제 시스템에 알고리즘을 구현하여 실제 작업에 대해서 성능을 측정 비교&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Simulation(모의 실현)
    &lt;ul&gt;
      &lt;li&gt;알고리즘을 모의 프로그램으로 작성후 trace를 입력으로 하여 결과 비교&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>zangzangs</name></author><category term="os" /><summary type="html">사용자 프로그램이 수행되는 과정은 CPU 작업과 I/O 작업의 반복으로 수행된다.</summary></entry><entry><title type="html">(4) 프로세스 관리</title><link href="http://localhost:4000/os04" rel="alternate" type="text/html" title="(4) 프로세스 관리" /><published>2021-04-02T19:18:00+09:00</published><updated>2021-04-02T19:18:00+09:00</updated><id>http://localhost:4000/os04</id><content type="html" xml:base="http://localhost:4000/os04">&lt;h2 id=&quot;프로세스의-개념&quot;&gt;&lt;strong&gt;프로세스의 개념&lt;/strong&gt;&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Process is &lt;strong&gt;&lt;span style=&quot;color:red;&quot;&gt;a Programin execution &lt;/span&gt;&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;&lt;span style=&quot;color:red&quot;&gt;실행중인 프로그램&lt;/span&gt;&lt;/strong&gt; 을 프로세스라 한다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;프로세스의 문맥(context)
    &lt;blockquote&gt;
      &lt;p&gt;프로세스가 현재 &lt;strong&gt;어떤 상태&lt;/strong&gt;에서 수행되고 있는지 정확히 규명하기 위해 필요한 정보를 말한다.&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;프로세스 문맥은 크게 3가지로 &lt;strong&gt;하드웨어 문맥&lt;/strong&gt;, &lt;strong&gt;프로세스의 주소공간&lt;/strong&gt;, &lt;strong&gt;커널상의 문맥&lt;/strong&gt;으로 나누어 볼 수 있다.&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;CPU 수행 상태를 나타내는 &lt;strong&gt;하드웨어 문맥&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;Program Counter&lt;/li&gt;
          &lt;li&gt;각종 register&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;프로세스의 주소 공간&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;code, data, stack&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;프로세스 관련 &lt;strong&gt;커널&lt;/strong&gt; 자료 구조
        &lt;ul&gt;
          &lt;li&gt;PCB (Process Control Block)&lt;/li&gt;
          &lt;li&gt;Kernel stack (커널내의 주소)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;&lt;br /&gt;&lt;/h2&gt;

&lt;h2 id=&quot;프로세스의-상태&quot;&gt;&lt;strong&gt;프로세스의 상태&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;프로세스의 상태는 실행(running), 준비(ready), 봉쇄(blocked, wait, sleep)의 세 가지로 구분할 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;실행(Running)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;프로세스가 CPU를 잡고 기계어 instruction을 수행중인 상태를 말한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;준비(Ready)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;CPU만 보유하면 당장 명령을 수행 할 수 있도록 CPU를 기다리는 상태(메모리 등 다른 조건을 모두 만족)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;봉쇄(blocked, wait, sleep)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;CPU를 할당받더라도 당장 명령을 실행할 수 없는 상태를 말한다.
        &lt;ul&gt;
          &lt;li&gt;I/O 등의 event를 (스스로) 기다리는 상태&lt;/li&gt;
          &lt;li&gt;디스크에서 file을 읽어와야 하는 경우&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;시작 상태
    &lt;ul&gt;
      &lt;li&gt;프로세스가 시작되어 그 프로세스를 위한 각종 자료구조는 생성되었지만 아직 메모리 획득을 승인받지 못한 상태&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;완료 상태
    &lt;ul&gt;
      &lt;li&gt;프로세스가 종료되었으나 운영체제가 그 프로세스와 관련된 자료구조를 완전히 정리하지 못한 상태&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;​ &lt;strong&gt;Suspended (stoped)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;외부적인 이유로 프로세스의 수행이 정지된 상태&lt;/li&gt;
      &lt;li&gt;프로세스는 통째로 디스크에 swap out 된다&lt;/li&gt;
      &lt;li&gt;ex) 사용자 프로그램을 일시 정지시킨 경우 (break key) 시스템이 여러 이유로 프로세스를 잠시 중단시킴(메모리에 너무 많은 프로세스가 올라와 있을 때)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;Blocked: 자신이 요청한 event가 만족되면 Ready&lt;/li&gt;
    &lt;li&gt;Suspended: 외부에서 resume해 주어야 Active&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;div style=&quot;text-align:center;&quot;&gt;
  &lt;img src=&quot;/assets/images/operating_system/chap05_프로세스의_상태_변화도.png&quot; style=&quot;zoom:70%&quot; /&gt;
  프로세스의 상태 변화도
&lt;/div&gt;

&lt;h2 id=&quot;-1&quot;&gt;&lt;br /&gt;&lt;/h2&gt;

&lt;h2 id=&quot;process-control-block-pcb&quot;&gt;Process Control Block (PCB)&lt;/h2&gt;
&lt;p&gt;프로세스 제어블록이란 운영체제가 시스템 내의 프로세스들을 관리하기 위해 프로세스마다 유지하는 정보들을 담는 커널 내의 자료구조를 말한다.&lt;/p&gt;

&lt;div style=&quot;text-align:center;&quot;&gt;
  &lt;img src=&quot;/assets/images/operating_system/ch05_PCB구성.png&quot; style=&quot;zoom:50%&quot; /&gt;
  프로세스 제어블록(PCB)의 구성
&lt;/div&gt;

&lt;!-- 
- 다음의 구성요소를 가진다 (구조체로 유지)
  1. OS 관리상 사용하는 정보  
     - 프로세스 상태(Process state), Process ID  
     - 스케쥴링 정보(scheduling information), 우선순위(priority)  
  2. CPU 수행 관련 하드웨어 값  
     - Program counter  
     - registers(현 시점에 레지스터에 어떤 값을 저장하고 있는지)  
  3. 메모리 관련  
     - code, data, stack 의 위치정보  
  4. 파일 관련  
     - Open file descriptors
--&gt;

&lt;h2 id=&quot;-2&quot;&gt;&lt;br /&gt;&lt;/h2&gt;

&lt;h2 id=&quot;문맥-교환-context-switch&quot;&gt;&lt;strong&gt;문맥 교환 (Context Switch)&lt;/strong&gt;&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;한 프로세스에서 다른 프로세스로 CPU의 제어권을 넘겨주는 과정&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;CPU가 다른 프로세스에게 넘어갈 때 운영체제는 다음을 수행한다.
    &lt;ol&gt;
      &lt;li&gt;CPU를 내어주는 프로세스의 문맥(context)를 그 프로세스의 PCB에 저장&lt;/li&gt;
      &lt;li&gt;CPU를 새롭게 얻는 프로세스의 문맥(context)을 PCB로부터 읽어 실제 하드웨어로 복원&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;문맥교환이 아닌 것과 혼동하지 말자. 문맥교환은 프로세스A에서 프로세스B로 넘어가는것&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;System call이나 interrupt 발생시 반드시 context switch가 일어나는 것은 아니다
    &lt;ol&gt;
      &lt;li&gt;&lt;strong&gt;문맥교환 &lt;span style=&quot;color:red&quot;&gt;X&lt;/span&gt;&lt;/strong&gt;
 사용자 프로세스 A -&amp;gt; interrupt or system call -&amp;gt; 커널모드) -&amp;gt; &lt;strong&gt;&lt;span style=&quot;color:red&quot;&gt;문맥 교환 없이 user 모드 복귀&lt;/span&gt;&lt;/strong&gt; -&amp;gt; 사용자 프로세스 A&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;문맥교환 &lt;span style=&quot;color:blue&quot;&gt;O&lt;/span&gt;&lt;/strong&gt;
 사용자 프로세스 A -&amp;gt; interrupt or I/O 요청 system call  -&amp;gt; 커널모드(ISR or system call) -&amp;gt; &lt;strong&gt;&lt;span style=&quot;color:blue&quot;&gt;문맥 교환 발생&lt;/span&gt;&lt;/strong&gt; -&amp;gt; 사용자 프로세스 B&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;(1)의 경우에도 CPU 수행 정보 등 context의 일부를 PCB에 save해야 하지만 문맥교환을 하는 (2)의 경우 그 부담이 훨씬 크다. (eg. cache memory flush)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;-3&quot;&gt;&lt;br /&gt;&lt;/h2&gt;

&lt;h2 id=&quot;프로세스를-스케줄링하기-위한-큐&quot;&gt;&lt;strong&gt;프로세스를 스케줄링하기 위한 큐&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;운영체제는 하드웨어와 소프트웨어 자원을 줄세우기 위해 여러 Queue를 두어 사용한다. 프로세스들은 각 Queue들을 오가며 수행된다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Job queue&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;현재 시스템 내에 있는 모든 프로세스의 집합&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Ready queue&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;현재 메모리 내에 있으면서 CPU를 잡아서 실행되기를 기다리는 프로세스의 집합&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Device queues&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;I/O device의 처리를 기다리는 프로세스의 집합&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-4&quot;&gt;&lt;br /&gt;&lt;/h2&gt;

&lt;h2 id=&quot;스케줄러-scheduler&quot;&gt;&lt;strong&gt;스케줄러 (Scheduler)&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;스케줄러란 어떤 프로세스에게 자원을 할당할지를 결정하는 운영체제 커널의 코드를 지칭한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;long-term-scheduler장기-스케줄러-or-job-scheduler&quot;&gt;&lt;strong&gt;Long-term scheduler(장기 스케줄러 or job scheduler)&lt;/strong&gt;&lt;/h4&gt;
    &lt;ul&gt;
      &lt;li&gt;시작 프로세스 중 어떤 것들을 &lt;strong&gt;ready queue&lt;/strong&gt;로 보낼지 결정&lt;/li&gt;
      &lt;li&gt;프로세스에 memory(및 각종 자원)을 주는 문제&lt;/li&gt;
      &lt;li&gt;degree of Multiprogramming을 제어&lt;/li&gt;
      &lt;li&gt;time sharing system에는 보통 장기 스케줄러가 없음(무조건 ready)&lt;/li&gt;
    &lt;/ul&gt;

    &lt;blockquote&gt;
      &lt;ul&gt;
        &lt;li&gt;프로세스 상태도에서 admitted 해주는게 장기스케줄러의 역할&lt;/li&gt;
        &lt;li&gt;&lt;em&gt;현대의 운영체제(시분할 시스템)는 하드웨어의 발전으로 장기 스케줄러 사용하지 않음&lt;/em&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;short-term-scheduler단기-스케줄러-or-cpu-scheduler&quot;&gt;&lt;strong&gt;Short-term scheduler(단기 스케줄러 or CPU scheduler)&lt;/strong&gt;&lt;/h4&gt;
    &lt;ul&gt;
      &lt;li&gt;ready queue에 있는 프로세스들 중 다음번에 running 시킬 프로세스를 결정&lt;/li&gt;
      &lt;li&gt;프로세스에 CPU를 할당하는 역할&lt;/li&gt;
      &lt;li&gt;매우 빈번하게 호출되므로 빨라야 한다 (millisecond 단위)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;medium-term-scheduler중기-스케줄러-or-swapper&quot;&gt;&lt;strong&gt;Medium-Term Scheduler(중기 스케줄러 or Swapper)&lt;/strong&gt;&lt;/h4&gt;
    &lt;blockquote&gt;
      &lt;p&gt;현대의 운영체제(시분할 시스템)에서 장기 스케줄러 사용이 낮아지면서 중기 스케줄러를 사용&lt;/p&gt;
    &lt;/blockquote&gt;
    &lt;ul&gt;
      &lt;li&gt;많은 프로세스에게 메모리를 할당해 시스템의 성능이 저하되는 일을 조절한다
        &lt;ul&gt;
          &lt;li&gt;프로세스에게서 메모리를 빼앗음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;여유 공간 마련을 위해 프로세스를 통째로 메모리에서 디스크의 swap 영역으로 저장함 &lt;strong&gt;(swap out)&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;봉쇄(block) 상태에 있는 프로세스가 0순위로 swap out&lt;/li&gt;
          &lt;li&gt;그래도 부족하면 타이머 인터럽트로 ready queue로 이동하는 프로세스를 추가적으로 swap out&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;degree of Multiprogramming을 제어&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div style=&quot;text-align:center;&quot;&gt;
  &lt;img src=&quot;/assets/images/operating_system/chap05_프로세스_상태_변화도_중지_상태_포함.png&quot; style=&quot;zoom:90%&quot; /&gt;
  중지 상태를 포함한 프로세스의 상태 변화도
&lt;/div&gt;

&lt;h2 id=&quot;-5&quot;&gt;&lt;br /&gt;&lt;/h2&gt;

&lt;!-- ## Thread (쓰레드)

&gt; **A &lt;span style=&quot;color:red&quot;&gt;thread&lt;/span&gt; (or &lt;span style=&quot;color:red&quot;&gt;lightweight process&lt;/span&gt;) is a basic unit of CPU utilization**

- Thread의 구성
  - program counter
  - register set
  - stack space
- Thread가 동료 Thread와 공유하는 부분(=task)
  - code section
  - data section
  - OS resources
- 전통적인 개념의 heavyweight process는 하나의 thread를 가지고 있는 task로 볼 수 있다
- 다중 스레드로 구성된 테스크 구조에서는 하나의 서버 스레드가 blocked (waiting) 상태인 동안에도 동일한 태스크 내의 다른 스레드가 실행(running)되어 빠른 처리를 할 수 있다.
- 동일한 일을 수행하는 다중 스레드가 협력하여 높은 처리율(throughput)과 성능 향상을 얻을 수 있다
- 스레드를 사용하면 병렬성을 높일 수 있다



### Benefits of Threads

- Responsiveness
  - 동시 처리로 빠른 응답성을 제공한다.
- Resource Sharing
  -  프로세스의 리소스인 code, data를 n개의 쓰레드가 공유할 수 있다.(stack 제외)
- Economy
  - creating &amp; CPU switching thread (rather than a process)
  - Solaris의 경우 위 두 가지 overhead가 각각 30배, 5배
- Utilization of MP Architectures
  - 멀티 프로세서 아키텍처의 사용에서 각각의 쓰레드를 다른 프로세서에서 병렬로 실행한다.

&lt;br&gt;

### Implementation of Threads

- Kernel Threads 

  &gt; Some are supported by kernel  
  &gt;
  &gt; 운영체제 커널이 지원하는 Threads 

  - Windows
  - Solaris
  - Digital UNIX, Mach

- User Threads

  &gt; Others are Supported by library
  &gt;
  &gt; 사용자가 에서 Threads를 관리

  - POSIX Pthreads
  - Mach C-threads
  - Solaris threds

- Some are real-time threads 

&lt;br&gt;
--- ,,
--&gt;

&lt;h2 id=&quot;프로세스-생성&quot;&gt;&lt;strong&gt;프로세스 생성&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;시스템이 부팅된 후 최초의 프로세스는 운영체제가 직접 생성하지만 그다음부터는 이미 존재하는 프로세스가 다른 프로세스를 복제 생성하게 된다. 이때 프로세스를 생성한 프로세스를  &lt;strong&gt;&lt;span style=&quot;color:blue&quot;&gt;부모 프로세스(parent process)&lt;/span&gt;&lt;/strong&gt; 라고 하고 새롭게 생성된 프로세스를  &lt;strong&gt;&lt;span style=&quot;color:blue&quot;&gt; 자식 프로세스(children process)&lt;/span&gt;&lt;/strong&gt; 라고 한다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;부모 프로세스(parent process)&lt;/strong&gt; 가 &lt;strong&gt;자식 프로세스(children process)&lt;/strong&gt; 생성&lt;/li&gt;
  &lt;li&gt;프로세스의 트리(계층 구조) 형성&lt;/li&gt;
  &lt;li&gt;프로세스는 자원을 필요로함
    &lt;ul&gt;
      &lt;li&gt;운영체제로부터 받는다&lt;/li&gt;
      &lt;li&gt;부모와 공유한다
        &lt;ul&gt;
          &lt;li&gt;자원의 공유
            &lt;ul&gt;
              &lt;li&gt;부모와 자식이 모든 자원을 공유하는 모델&lt;/li&gt;
              &lt;li&gt;일부를 공유하는 모델&lt;/li&gt;
              &lt;li&gt;전혀 공유하지 않는 모델&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;수행 (Execution)
    &lt;ul&gt;
      &lt;li&gt;부모와 자식은 공존하며 수행되는 모델&lt;/li&gt;
      &lt;li&gt;자식이 종료(terminate)될 때까지 부모가 기다리는(wait) 모델&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;주소 공간 (Address space)
    &lt;ul&gt;
      &lt;li&gt;자식은 부모의 공간을 복사함 (binary and OS data)&lt;/li&gt;
      &lt;li&gt;자식은 부모의 공간을 복사함 (binary and OS data)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;유닉스의 예
    &lt;ul&gt;
      &lt;li&gt;&lt;span style=&quot;color:red&quot;&gt;fork()&lt;/span&gt; 시스템 콜이 새로운 프로세스를 생성
        &lt;ul&gt;
          &lt;li&gt;부모를 그대로 복사 (OS data except PID + binary)&lt;/li&gt;
          &lt;li&gt;주소 공간 할당&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;fork 다음에 이어지는 &lt;span style=&quot;color:red&quot;&gt;exec()&lt;/span&gt; 시스템 콜을 통해 새로운 프로그램을 메모리에 올림&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;프로세스가 마지막 명령을 수행한 후 운영체제에게 이를 알려줌(&lt;span style=&quot;color:red&quot;&gt;exit&lt;/span&gt;)
    &lt;ul&gt;
      &lt;li&gt;자식이 부모에게 output data를 보냄 (via &lt;span style=&quot;color:red&quot;&gt;wait&lt;/span&gt;)&lt;/li&gt;
      &lt;li&gt;프로세스의 각종 자원들이 운영체제에게 반납됨&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;부모 프로세스가 자식의 수행을 종료시킴 (&lt;span style=&quot;color:red&quot;&gt;abort&lt;/span&gt;)
    &lt;ul&gt;
      &lt;li&gt;자식이 할당 자원의 한계치를 넘어섬&lt;/li&gt;
      &lt;li&gt;자식에게 할당된 태스크가 더 이상 필요하지 않음&lt;/li&gt;
      &lt;li&gt;부모가 종료(exit)하는 경우
        &lt;ul&gt;
          &lt;li&gt;운영체제는 부모 프로세스가 종료하는 경우 자식 프로세스가 더 이상 수행되도록 두지 않는다(종료해버림)&lt;/li&gt;
          &lt;li&gt;프로세스의 계층 구조(트리)에 따라 단계적인 종료가 됨&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;프로세스-생성-절차&quot;&gt;프로세스 생성 절차&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Fork() 시스템 콜&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;프로세스 ID를 제외한 모든 내용을 그대로 복제 생성한다.&lt;/li&gt;
      &lt;li&gt;부모와 자식 프로세스는 서로 다른 주소공간을 갖는다.(주소공간 내용은 동일)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;exec() 시스템 콜&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;하나의 프로세스를 완전히 새로운 프로세스로 덮어쓰는 명령&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;wait() 시스템 콜&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;자식 프로세스가 종료되기를 기다리며 부모 프로세스가 봉쇄 상태에 머무르도록 할 때 사용된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;exit() 시스템 콜&lt;/strong&gt;
프로세스의 종료 종료하는 명령이다. 종료 명령은 자발적 종료와 비자발적 종료로 구분 된다.
    &lt;ul&gt;
      &lt;li&gt;자발적 종료
        &lt;ul&gt;
          &lt;li&gt;마지막 statement 수행 후 exit() 시스템 콜&lt;/li&gt;
          &lt;li&gt;프로그램에 명시적으로 적어주지 않아도 main함수가 리턴되는 위치에 컴파일러가 넣어줌&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;비자발적 종료
        &lt;ol&gt;
          &lt;li&gt;자식 프로세스가 한계치를 넘어서는 자원 요청하는 경우&lt;/li&gt;
          &lt;li&gt;자식에게 할당된 작업이 더 이상 필요하지 않는 경우&lt;/li&gt;
          &lt;li&gt;부모 프로세스가 종료되는 경우&lt;/li&gt;
          &lt;li&gt;키보드로 kill, break 등을 친 경우&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-6&quot;&gt;&lt;br /&gt;&lt;/h2&gt;

&lt;h2 id=&quot;프로세스-간-협력&quot;&gt;&lt;strong&gt;프로세스 간 협력&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;원칙적으로 프로세스는 각자 자신만의 독립적인 주소 공간을 가지기 때문에 &lt;em&gt;다른 프로세스의 주소 공간을 참조하는 것은 허용되지 않는다.&lt;/em&gt; 그러나 경우에 따라서 &lt;em&gt;프로세스들 간의 협력이 효율을 증가시키는 점에서 더 생산적일 수 있다.&lt;/em&gt; 따라서 &lt;strong&gt;운영체제는 프로세스들간의 협력을 위한 매커니즘을 제공&lt;/strong&gt;한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;독립적 프로세스(Independent process)&lt;/strong&gt;
프로세스는 각자의 주소 공간을 가지고 수행되므로 원칙적으로 하나의 프로세스는 다른 프로세스의 수행에 영향을 미치지 못함&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;협력 프로세스(Cooperating process)&lt;/strong&gt;
프로세스 협력 메커니즘을 통해 하나의 프로세스가 다른 프로세스의 수행에 영향을 미칠 수 있음&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;프로세스-간-협력-메커니즘-ipc-interprocess-communication&quot;&gt;프로세스 간 협력 메커니즘 (IPC: Interprocess Communication)&lt;/h3&gt;

&lt;p&gt;IPC란 하나의 컴퓨터 안에서 실행 중인 서로 다른 프로세스 간에 발생하는 통신과 동기화를 이루기 위한 매커니즘을 말한다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;메시지를 전달하는 방법(Message passing)&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;프로세스 사이에 공유 변수(shared variable)를 일체 사용하지 않고 통신하는 시스템&lt;/li&gt;
      &lt;li&gt;커널을 통해 메시지를 주고 받음&lt;/li&gt;
      &lt;li&gt;커뮤니케이션 링크를 생성하고 send(), receive()&lt;/li&gt;
      &lt;li&gt;커뮤니케이션 링크 방법
        &lt;ol&gt;
          &lt;li&gt;Direct Communication
            &lt;ul&gt;
              &lt;li&gt;통신하려는 프로세스의 이름을 명시적으로 표시&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;Indirect Communication
            &lt;ul&gt;
              &lt;li&gt;mailbox (또는 port)를 통해 메시지를 간접 전달
&lt;br /&gt;&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;주소 공간을 공유하는 방법(Shared memory)&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;서로 다른 프로세스 간에 일부 주소 공간을 공유하게 하는 공유 메모리 매커니즘&lt;/li&gt;
      &lt;li&gt;같은 메모리 공간 사용으로 일관성 문제가 유발될 수 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;Thread는 사실상 하나의 프로세스이므로 프로세스 간 협력으로 보기는 어렵지만 동일한 프로세스를 구성하는 Threads들 간에는 주소 공간을 공유하므로 협력이 가능&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div style=&quot;text-align:center;&quot;&gt;
  &lt;img src=&quot;/assets/images/operating_system/chap05_ipc.png&quot; style=&quot;zoom:60%&quot; /&gt;
  hared memory VS Message passing
&lt;div&gt;

&lt;/div&gt;&lt;/div&gt;</content><author><name>zangzangs</name></author><category term="os" /><summary type="html">프로세스의 개념</summary></entry><entry><title type="html">(3) 프로그램의 구조와 실행</title><link href="http://localhost:4000/os03" rel="alternate" type="text/html" title="(3) 프로그램의 구조와 실행" /><published>2021-03-28T19:18:00+09:00</published><updated>2021-03-28T19:18:00+09:00</updated><id>http://localhost:4000/os03</id><content type="html" xml:base="http://localhost:4000/os03">&lt;h2 id=&quot;프로그램의-실행&quot;&gt;프로그램의 실행&lt;/h2&gt;

&lt;p&gt;프로그램의 실행은 두가지 중요한 의미를 가진다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;파일 시스템에 존재하던 실행파일이 메모리에 적재된다는 의미&lt;/li&gt;
  &lt;li&gt;프로그램이 CPU를 할당받고 명령을 수행하고 있는 상태&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;파일 시스템에 있는 실행 파일이 메모리에 적재될 때, 실행파일 전체가 메모리에 올라가지 않는다. 일부분만 메모리에 올라가고 나머지는 디스크의 특정영역인 스왑 영역에 존재한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;가상-메모리-virtual-memory&quot;&gt;가상 메모리 (virtual memory)&lt;/h2&gt;

&lt;p&gt;프로세스의 주소 공간은 코드(code), 데이타(data), 스택(stack)영역으로 구성된다. 이러한 주소 공간을 우리는 가상 메모리 (또는 논리적 메모리: logical memory)라고 부른다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;code
    &lt;ul&gt;
      &lt;li&gt;사용자가 작성한 프로그램 함수들의 코드가 CPU에서 수행할 수 있는 기계어 명령 형태로 변환되어 저장되는 공간&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;data
    &lt;ul&gt;
      &lt;li&gt;전역 변수 등 프로그램이 사용하는 데이터를 저장하는 공간&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;stack
    &lt;ul&gt;
      &lt;li&gt;호출된 함수의 수행을 마치고 복귀할 주소 및 데이터를 임시로 저장하는 공간&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;커널-주소-공간의-내용&quot;&gt;커널 주소 공간의 내용&lt;/h2&gt;

&lt;p&gt;운영체제도 하나의 프로세스이기 때문에 커널 역시 동일한 주소 공간인 code, data, stack 영역을 갖는다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;code&quot;&gt;code&lt;/h4&gt;
    &lt;ul&gt;
      &lt;li&gt;시스템 콜, 인터럽트 처리 코드&lt;/li&gt;
      &lt;li&gt;CPU, 메모리 등 자원 관리를 위한 코드&lt;/li&gt;
      &lt;li&gt;편리한 인터페이스 제공을 위한 코드&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;data&quot;&gt;data&lt;/h4&gt;
    &lt;ul&gt;
      &lt;li&gt;PCB(Process Controll Block)
        &lt;ul&gt;
          &lt;li&gt;현재 수행 중인 프로세스의 상태, CPU 사용 정보 등을 유지하기 위한 자료구조&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;CPU, Memory 등 하드웨어 자원을 관리하기 위한 자료구조가 저장&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;stack&quot;&gt;stack&lt;/h4&gt;
    &lt;ul&gt;
      &lt;li&gt;각 Process의 커널 스택을 저장
        &lt;ul&gt;
          &lt;li&gt;프로세스는 함수 호출시 자신의 복귀 주소를 저장하지만, 커널은 커널 내의 주소가 된다.&lt;/li&gt;
          &lt;li&gt;각각의 프로세스마다 별도의 스택을 두어 관리한다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;사용자-프로그램이-사용하는-함수&quot;&gt;사용자 프로그램이 사용하는 함수&lt;/h2&gt;
&lt;p&gt;함수는 크게 두가지로 나눌 수 있다. 프로세스 함수와 커널함수&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;사용자 정의 함수(프로세스 함수)
    &lt;ul&gt;
      &lt;li&gt;자신의 프로그램에서 정의한 함수&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;라이브러리 함수(프로세스 함수)
    &lt;ul&gt;
      &lt;li&gt;자신의 프로그램에서 정의하지 않고 갖다 쓴 함수&lt;/li&gt;
      &lt;li&gt;자신의 프로그램의 실행 파일에 포함되어 있다.&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;커널 함수
    &lt;ul&gt;
      &lt;li&gt;운영체제 프로그램의 함수&lt;/li&gt;
      &lt;li&gt;커널 함수의 호출 = 시스템 콜&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;인터럽트&quot;&gt;인터럽트&lt;/h2&gt;

&lt;p&gt;CPU는 매번 프로그램 카운터가 가리키고 있는 지점의 명령을 하나씩 수행하고 나서, 다음 명령을 수행하기 직전에 인터럽트 라인이 세팅되었는지 체크한다. 인터럽트 라인 체크를 통해 인터럽트가 발생했으면 CPU는 현재 수행하던 프로세스를 멈추고 운영체제의 인터럽트 처리 루틴으로 이동해서 인터럽트 처리를 수행한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;그렇다면 인터럽트 처리중에 또다른 인터럽트가 발생하는 경우는 어떻게 되는가?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;원직적으로는 인터럽트 처리중에 또 다른 인터럽트의 처리를 허용하지 않는다.
    &lt;ul&gt;
      &lt;li&gt;앞서 변경중이던 데이터를 또다른 인터럽트가 발생해 처리하게 되면 의도하지 않은 결과값으로 바뀔 수 있기 때문이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;예외적인 경우가 존재한다.
    &lt;ul&gt;
      &lt;li&gt;인터럽트마다 중요도가 다르다.&lt;/li&gt;
      &lt;li&gt;상대적으로 낮은 중요도를 가진 인터럽트를 처리하는 도중 높은 중요도의 인터럽트 발생을 허용한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;프로세스의-두-가지-실행-상태&quot;&gt;프로세스의 두 가지 실행 상태&lt;/h2&gt;
&lt;p&gt;mode bit에 따라 user mode, kernel mode를 반복하며 실행된다. 프로그램이 시작되어 종료될 때까지 다양한 함수 호출을 하며 실행되는데, 이를 사용자 모드와 커널모드의 실행 상태로 구분 지을 수 있다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;사용자 모드(user mode)
    &lt;ul&gt;
      &lt;li&gt;프로그램이 사용자 정의함수나 라이브러리 함수를 호출&lt;/li&gt;
      &lt;li&gt;시스템 콜의 실행이 끝나고 시스템 콜 이후의 명령을 수행하는 경우&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;커널 모드(kernel mode)
    &lt;ul&gt;
      &lt;li&gt;시스템 콜을 하는 경우&lt;/li&gt;
      &lt;li&gt;프로그램의 실행이 끝날 때 커널모드로 진입하여 프로그램을 종료함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;</content><author><name>zangzangs</name></author><category term="os" /><summary type="html">프로그램의 실행</summary></entry><entry><title type="html">(2) 컴퓨터 시스템의 동작 원리</title><link href="http://localhost:4000/os02" rel="alternate" type="text/html" title="(2) 컴퓨터 시스템의 동작 원리" /><published>2021-03-21T19:18:00+09:00</published><updated>2021-03-21T19:18:00+09:00</updated><id>http://localhost:4000/os02</id><content type="html" xml:base="http://localhost:4000/os02">&lt;h2 id=&quot;컴퓨터-시스템-구조&quot;&gt;컴퓨터 시스템 구조&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;div style=&quot;text-align:center;&quot;&gt;
  &lt;img src=&quot;../..\assets\images\operating_system\chap03_computer_system_structure.png&quot; style=&quot;zoom:60%&quot; /&gt;
  &lt;span style=&quot;color:gray; size:10&quot;&gt;&lt;컴퓨터 시스템=&quot;&quot; 구조=&quot;&quot;&gt;&amp;lt;/span&amp;gt;
&amp;lt;/div&amp;gt;

---

### 1. CPU
중앙처리장치라 불리는 CPU는 인간의 **두뇌**와 같은 역할을 합니다. **중앙처리장치** 라는 말 그대로 중앙에서 사용자가 입력한 명령어를 해석하고 연산한 후 그 결과를 처리합니다.

&lt;br /&gt;

### 2. 메모리
 랜덤 액세스 메모리 즉, 램(RAM)은 임의의 영역에 접근하여 읽고 쓰기가 가능한 주기억 장치다. RAM은 어느 위치에 저장된 데이터든지 접근(읽기 및 쓰기)하는 데 동일한 시간이 걸리는 메모리이기에 ‘랜덤(Random, 무작위)’이라는 명칭이 주어진다. 
 
&lt;br /&gt;

### 3. Device Controller
- I/O device controller
  - 해당 I/O 장치 유형을 관리하는 일종의 작은 CPU
  - 제어 정보를 위해 control register, status register가 있다.
  - local buffer를 갖는다 (=일종의 data register)
- I/O는 실제 device와 local buffer 사이에서 일어남
- Device controller는 I/O가 끝났을 경우 interrupt로 CPU에 그 사실을 알림

&amp;gt; device driver(장치구동기)  
&amp;gt; : os 코드 중 각 장치별 처리루틴 -&amp;gt; software  
&amp;gt; device controller(장치제어기)  
&amp;gt; : 각 장치를 통제하는 일종의 작은 cpu -&amp;gt; hardware

&lt;br /&gt;

### 4. Interrupt line
CPU로 인터럽트 신호를 보낼 수 있는 하드웨어 라인

&lt;br /&gt;

### 5. Mode bit
사용자 프로그램의 잘못된 수행으로 다른 프로그램 및 운영체제에 피해가 가지 않도록 하기 위한 보호장치가 필요
Mode bit을 통해 하드웨어적으로 두 가지 모드의 operation 지원

&amp;gt; 1 &lt;span style=&quot;color:blue&quot;&gt;사용자 모드&lt;/span&gt; : 사용자 프로그램 수행  
&amp;gt; 0 &lt;span style=&quot;color:red&quot;&gt;모니터 모드&lt;/span&gt; : OS 코드 수행 (=커널 모드, 시스템 모드)  

- 보안을 해칠 수 있는 중요한 명령어는 모니터 모드에서만 수행 가능한 **'특권명령'** 으로 규정
- Interrupt나 Exception 발생시 하드웨어가 mode bit을 0으로 변경
- 사용자 프로그램에게 CPU를 넘기기 전에 mode bit을 1로 변경

&lt;br /&gt;

### 6. Timer
- 타이머
  - 정해진 시간이 흐른 뒤 운영체제에게 제어권이 넘어가도록 인터럽트를 발생
  - 타이머는 매 클럭 틱 때마다 1씩 감소
  - 타이머 값이 -이 되면 타이머 인터럽트 발생
  - CPU를 특정 프로그램이 독점하는 것으로부터 보호
  
- 타이머는 time sharing을 구현하기 위해 널리 이용됨
- 타이머는 현재 시간을 계산하기 위해서도 사용

&lt;br /&gt;

### 7. DMA Controller

메모리에 접근할 수 있는 장치는 CPU가 유일하다. 메모리는 CPU의 작업 공간이다. I/O장치나 다른 장치들이 접근 할 수 없다. 그렇다보니 1ms 마다 인터럽트가 발생한다면 CPU는 계속해서 자잘한 인터럽트를 처리해야하는 이슈가 있다. 그래서 메모리에 접근 할 수 있도록 도와주는 장치가 DMA 컨트롤러이다. 

- 빠른 입출력 장치를 메모리에 가까운 속도로 처리하기 위해 사용
- CPU의 중재 없이 device controller가 device의 buffer storage의 내용을 메모리에 block 단위로 직접 전손
- 바이트 단위가 아니라 block 단위로 인터럽트를 발생시킴
- 
&lt;br /&gt;

### 8. PC(Program counter)
CPU의 레지스터중 하나.
pc는 다음번에 실행할 명령어의 주소를 가지고 있다.
하나의 기계어가 종료 이후의 다음 위치를 가리킨다.

&lt;br /&gt;

---

## 인터럽트(Interrupt)
### 인터럽트
- 현대의 운영체제는 인터럽트에 의해 구동된다.
- 인터럽트 당한 시점의 레지스터와 Program counter를 save 한 후 CPU의 제어를 인터럽트 처리 루틴에 넘긴다.

&lt;br /&gt;

### 넓은 의미의 interrupt
- 하드웨어 인터럽트
  - 하드웨어가 발생시킨 인터럽트
- 소프트웨어 인터럽트  
    - Exception : 프로그램이 오류를 범한 경우
    - Systeme Call : 프로그램이 커널 함수를 호출하는 경우

&lt;br /&gt;

### 인터럽트 관련 용어
- 인터럽트 백터  
  해당 인터럽트 처리 루틴 주소를 가지고 있음
- 인터럽트 처리 루틴(=Interrupt Service Routine, 인터럽트 핸들러)  
  해당 인터럽트를 처리하는 커널 함수

### 동작
1. 인터럽트가 발생하면 CPU는 하던 일을 멈추고 커널 내에서 해당 인터럽트의 처리를 위해 정의된 코드를 찾게된다.  
2. 운영체제는 할 일을 쉽게 찾아가기 위해 인터럽트 벡터(interrupt vector)를 가지고 있다. 인터럽트 백터란 인터럽트 종류마다 번호를 정해서 번호에 따라 처리해야 할 코드가 위치한 부분을 가리키는 자료구조를 말한다.  
3. 인터럽트 백터를 따라가면 실제 처리해야 할 코드는 인터럽트 처리 루틴(Interrupt service routine) 또는 인터럽트 핸들러(Interrupt handler)라고 불리는 다른 곳에 정의된다.  
 4. 인터럽트 처리 루틴을 통해 해당되는 인터럽트 처리를 완료하고 나면 원래 수행하던 작업으로 돌아가 중단되었던 일을 계속해서 수행한다.  

&lt;br /&gt;

### 시스템 콜(System Call)
사용자 프로그램이 운영체제의 서비스를 받기 위해 커널함수(운영체제)를 호출하는 것


&lt;br /&gt;

&amp;gt; 질문: 운영체제한테 CPU가 넘어가는 경우  
&amp;gt; - 인터럽트 발생(Interrupt Line 사용하는 경우)  
&amp;gt;   - 하드웨어 장치들이 I/O가 인터럽트를 요청 할 때  
&amp;gt;   - timer 가 정해진 시간이 지난 후에 CPU에 제어권을 넘긴다.  
&amp;gt;   - 시스템 콜 발생시
&amp;gt; - Exception 발생시

 &lt;br /&gt;

---

## 동기식 입출력과 비동기식 입출력

- 동기식 입출력(synchronous I/O)
  - I/O 요청 후 입출력 작업이 완료된 후에야 제어가 사용자 프로그램에 넘어감
  - 구현 방법1
    - I/O가 끝날 때까지 CPU를 낭비시킴
    - 매시점 하나의 I/O만 일어날 수 있음
  - 구현 방법2
    - I/O가 완료될 때까지 해당 프로그램에게서 CPU를 빼앗음
    - I/O 처리를 기다리는 줄에 그 프로그램을 줄 세움
    - 다른 프로그램에게 CPU를 줌

- 비동기식 입출력(asynchronous I/O)
  - I/O가 시작된 후 입출력 작업이 끝나기를 기다리지 않고 제어가 사용자 프로그램에 즉시 넘어감

&amp;gt; 두 경우 모두 I/O 완료는 인터럽트로 알려준다.

&lt;br /&gt;
&lt;/컴퓨터&gt;&lt;/span&gt;&lt;/div&gt;</content><author><name>zangzangs</name></author><category term="os" /><summary type="html">컴퓨터 시스템 구조</summary></entry><entry><title type="html">(1) 운영체제 개요</title><link href="http://localhost:4000/os01" rel="alternate" type="text/html" title="(1) 운영체제 개요" /><published>2021-03-13T19:18:00+09:00</published><updated>2021-03-13T19:18:00+09:00</updated><id>http://localhost:4000/os01</id><content type="html" xml:base="http://localhost:4000/os01">&lt;h2 id=&quot;운영체제의-정의&quot;&gt;운영체제의 정의&lt;/h2&gt;
&lt;p&gt;하드웨어 바로 위에 설치되어 사용자 및 다른 모든 소프트웨어와 하드웨어를 연결하는 소프트웨어 계층&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div style=&quot;text-align:center;&quot;&gt;
&lt;img src=&quot;/assets/images/operating_system/chap02_os.png&quot; style=&quot;zoom:67%;&quot; /&gt;
&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;운영체제의-기능&quot;&gt;운영체제의 기능&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;자원을 효율적으로 관리한다.
    &lt;ul&gt;
      &lt;li&gt;효율성: 효율적이나 일부가 지나치게 희생되지 않도록&lt;/li&gt;
      &lt;li&gt;형평성: 프로그램들 간의 자원을 형평성 있게 분배&lt;/li&gt;
      &lt;li&gt;보안 및 보호&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;사용자 및 운영체제 자신의 보호한다.&lt;/li&gt;
  &lt;li&gt;프로세스, 파일, 메시지 등을 관리한다.&lt;/li&gt;
  &lt;li&gt;컴퓨터 시스템을 편리하게 사용할 수 있는 환경을 제공한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;운영체제의-분류&quot;&gt;운영체제의 분류&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;동시 작업 가능 여부
    &lt;ul&gt;
      &lt;li&gt;단일작업(single tasking)&lt;/li&gt;
      &lt;li&gt;다중작업(multi tasking)&lt;span style=&quot;color:red&quot;&gt; ✓pick&lt;/span&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;사용자 수
    &lt;ul&gt;
      &lt;li&gt;단일 사용자&lt;/li&gt;
      &lt;li&gt;다중 사용자&lt;span style=&quot;color:red&quot;&gt; ✓pick&lt;/span&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;처리방식
    &lt;ul&gt;
      &lt;li&gt;일괄처리 방식(batch processing)&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;시분할 방식(time sharing system)&lt;/strong&gt;&lt;span style=&quot;color:red&quot;&gt; ✓pick&lt;/span&gt;&lt;/li&gt;
      &lt;li&gt;실시간(real time)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;운영-체제의-자원-관리-기능&quot;&gt;운영 체제의 자원 관리 기능&lt;/h2&gt;

&lt;h3 id=&quot;1-cpu-스케쥴링cpu-scheduling&quot;&gt;1. CPU 스케쥴링(CPU scheduling)&lt;/h3&gt;
&lt;p&gt;CPU를 가장 효율적으로 사용하면서도, 특정 프로세스가 불이익을 당하지 않도록 하는 것&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;선입선출
CPU를 사용하기 위해 도착한 프로세스들 중 먼저 온 것을 먼저 처리해주는 방식&lt;/li&gt;
  &lt;li&gt;라운드 로빈(Round Robin)&lt;span style=&quot;color:red&quot;&gt; ✓pick&lt;/span&gt;
CPU를 한 번 할당받아 사용할 수 있는 시간을 일정하게 고정된 시간으로 제한한다.&lt;/li&gt;
  &lt;li&gt;우선순위
대기 중인 프로세스들에 우선순위를 부여하고 우선순위가 높은 프로세스에 CPU를 먼저 할당한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;2-메모리-관리&quot;&gt;2. 메모리 관리&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;고정분할 방식(fixed partition)
    &lt;ul&gt;
      &lt;li&gt;물리적 메모리를 일정 개수로 분할 하여 사용하는 방식을 말한다.&lt;/li&gt;
      &lt;li&gt;단점으로 분할 개수만큼만 프로그램을 사용할 수 있으며, 분할된 메모리보다 큰 프로그램은 적재가 불가능하다.&lt;/li&gt;
      &lt;li&gt;분할된 메모리보다 적은 메모리를 사용하는 프로그램이 적재가 되면 남는 메모리영역이 발생하는데 이를 &lt;span style=&quot;color:blue&quot;&gt;내부조각(internal fragment)&lt;/span&gt; 이라고 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;가변분할 방식(variable partition)
    &lt;ul&gt;
      &lt;li&gt;프로그램 크기에 맞게 메모리를 분할해서 사용하는 방식을 말한다.&lt;/li&gt;
      &lt;li&gt;메모리가 일정부분 20이 남았다고 했을 때, 40의 메모리를 가진 프로그램을 적재할 수 없어 남는 메모리 영역이 발생한다. 이를 &lt;span style=&quot;color:blue&quot;&gt;외부조각(external fragment)&lt;/span&gt;이라고 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;가상메모리(virtual memory)&lt;span style=&quot;color:red&quot;&gt; ✓pick&lt;/span&gt;
    &lt;ul&gt;
      &lt;li&gt;물리적 메모리보다 더 큰 프로그램이 실행되는 것을 지원한다.&lt;/li&gt;
      &lt;li&gt;현재 사용되고 있는 부분만 메모리에 올리고, 나머지는 하드디스크와 같은 보조기억장치에 저장해두었다가 필요할 때 적재하는 방식을 취한다. 이떄 사용되는 보조기억장치의 영역을 &lt;span style=&quot;color:blue&quot;&gt;스왑 영역(swap area)&lt;/span&gt;이라고 부른다.&lt;/li&gt;
      &lt;li&gt;가상메모리 주소 공간은 페이지(page)라는 동일한 크기의 작은 단위로 나뉘어 물리적 메모리와 스왑 영역에 일부분씩 저장된다. 이렇게 동일한 단위로 메모리를 나누는 기업을 &lt;span style=&quot;color:blue&quot;&gt;페이징(paging) 기법&lt;/span&gt;이라고 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;3-주변장치-및-입출력-관리&quot;&gt;3. 주변장치 및 입출력 관리&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;인터럽트
    &lt;ul&gt;
      &lt;li&gt;주변장치들이 CPU의 서비스가 필요한 경우 보내는 신호&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;컨트롤러
    &lt;ul&gt;
      &lt;li&gt;주변장치들이 메인 CPU에 인터럽트를 발생시켜 보고하는 역할&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;</content><author><name>zangzangs</name></author><category term="os" /><summary type="html">운영체제의 정의 하드웨어 바로 위에 설치되어 사용자 및 다른 모든 소프트웨어와 하드웨어를 연결하는 소프트웨어 계층</summary></entry><entry><title type="html">[Interview] JAVA</title><link href="http://localhost:4000/interview-java" rel="alternate" type="text/html" title="[Interview] JAVA" /><published>2021-03-12T19:18:00+09:00</published><updated>2021-03-12T19:18:00+09:00</updated><id>http://localhost:4000/interview-java</id><content type="html" xml:base="http://localhost:4000/interview-java">&lt;h1 id=&quot;java-interview&quot;&gt;Java Interview&lt;/h1&gt;
&lt;hr /&gt;
&lt;blockquote&gt;
  &lt;p&gt;java의 장단점&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;장점
      &lt;ul&gt;
        &lt;li&gt;운영체제에 독립적이다.
          &lt;ul&gt;
            &lt;li&gt;JVM에서 동작하기 때문에, 특적 운영체제에 종속되지 않는다.&lt;/li&gt;
          &lt;/ul&gt;
        &lt;/li&gt;
        &lt;li&gt;객체지향 언어이다.&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;</content><author><name>zangzangs</name></author><category term="interview" /><summary type="html">Java Interview java의 장단점 장점 운영체제에 독립적이다. JVM에서 동작하기 때문에, 특적 운영체제에 종속되지 않는다. 객체지향 언어이다.</summary></entry><entry><title type="html">[Interview] 데이터베이스</title><link href="http://localhost:4000/interview-database" rel="alternate" type="text/html" title="[Interview] 데이터베이스" /><published>2021-03-12T19:18:00+09:00</published><updated>2021-03-12T19:18:00+09:00</updated><id>http://localhost:4000/interview-database</id><content type="html" xml:base="http://localhost:4000/interview-database">&lt;h3 id=&quot;database-기술면접-준비&quot;&gt;Database 기술면접 준비&lt;/h3&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;트랜잭션&quot;&gt;트랜잭션&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;데이터베이스 내에 하나의 그룹으로 처리해야하는 명령문을 모아놓은 작업단위 또는 데이터 처리의 한 단위&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;acid-트랜잭션의-특징&quot;&gt;ACID, 트랜잭션의 특징&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Atomicity (원자성) &lt;br /&gt;
트랜잭션과 관련된 일은 모두 실행되던지 모두 실행되지 않도록 하던지를 보장하는 특성이다.&lt;/li&gt;
  &lt;li&gt;Consistency (일관성)&lt;br /&gt;
 트랜잭션이 성공했다면, 데이터베이스는 그 일관성을 유지해야 한다. 일관성은 특정한 조건을 두고, 그 조건을 만족하는지를 확인하는 방식으로 검사할 수 있다.&lt;/li&gt;
  &lt;li&gt;Isolation (독립성)&lt;br /&gt;
독립성. 트랜잭션을 수행하는 도중에 다른 연산작업이 끼어들지 못하도록 한다. 임계영역을 두는 것으로 달성할 수 있다.&lt;/li&gt;
  &lt;li&gt;Durability (지속성)&lt;br /&gt;
성공적으로 트랜잭션이 수행되었다면, 그 결과는 완전히 반영이 되어야 한다. 완전히 반영되면 로그를 남기게 되는데, 후에 이 로그를 이용해서 트랜잭션 수행전 상태로 되돌릴 수 있어야 한다. 때문에 트랜잭션은 로그저장이 완료된 시점에서 종료가 되어야 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;데이터베이스-언어의-종류-3가지&quot;&gt;데이터베이스 언어의 종류 3가지&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;DDL(Data Definition Language)
데이터베이스를 정의하는 언어이며, 데이터리를 생성, 수정, 삭제하는 등의 데이터의 전체의 골격을 결정하는 역할을 하는 언어 입니다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th&gt;종류&lt;/th&gt;
          &lt;th&gt;역할&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;CREATE&lt;/td&gt;
          &lt;td&gt;데이터베이스, 테이블 등을 생성하는 역할을 합니다.&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;ALTER&lt;/td&gt;
          &lt;td&gt;테이블을 수정하는 역할을 합니다.&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;DROP&lt;/td&gt;
          &lt;td&gt;데이터베이스,테이블을 삭제&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;RENAME&lt;/td&gt;
          &lt;td&gt;데이터베이스의 객체 이름을 변경&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;COMMENT&lt;/td&gt;
          &lt;td&gt;데이터에 주석 등을 추가한다.&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;TRUNCATE&lt;/td&gt;
          &lt;td&gt;테이블을 초기화 한다&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;DML(Data Manipulation Language)
정의된 데이터베이스에 입력된 레코드를 조회하거나 수정하거나 삭제하는 등의 역할을 하는 언어를 말합니다.
|종류|역할|
|—|—|
|SELECT|데이터를 조회하는 명령어|
|INSERT|데이터 삽입하는 명령어|
|UPDATE| 데이터를 수정하는 명령어|
|DELETE|데이터를 삭제하는 명령어|
|MERGE|데이터가 테이블에 없으면 INSERT, 있다면 UPDATE를 수행한다. UPSERT 라는 별명이 있다.|&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;DCL(Data Control Language)
데이터베이스에 접근하거나 객체에 권한을 주는등의 역할을 하는 언어를 입니다.
|종류|역할|
|—|—|
|GRANT|특정 데이터베이스 사용자에게 특정 작업에 대한 수행권한을 부여|
|REVOKE|특정 데이터베이스 사용자에게 특정 작업에 대한 수행 권한을 박탈, 회수|&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;TCL(Transaction Control Language)
데이터의 보안, 무결성, 회복, 병행 수행제어 등을 제어하는 역할을 하는 언어입니다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th&gt;종류&lt;/th&gt;
          &lt;th&gt;역할&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;COMMIT&lt;/td&gt;
          &lt;td&gt;트랜잭션의 작업 결과를 저장 반영한다.&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;ROLLBACK&lt;/td&gt;
          &lt;td&gt;데이터베이스를 마지막 COMMIT 시점으로 복원&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;SAVEPOIN&lt;/td&gt;
          &lt;td&gt;ROOLBACK시 저장위치까지 트랜잭션의 일부만 롤백 할 수 있다.&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;SET TRANSACTION&lt;/td&gt;
          &lt;td&gt;transaction 지정&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;오라클-힌트-oracle-hint&quot;&gt;오라클 힌트 (Oracle Hint)&lt;/h3&gt;
&lt;p&gt;오라클 옵티마이저에게 SQL문 실행을 위한 데이터를 스캐닝하는 경로, 조인하는 방법 등을 알려주기 위해 SQL 작성자가 직접 작성해주는 구문이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;옵티마이저란?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;정규화&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;튜플&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;카디널리티&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;JOIN&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;GROUP BY, HAVING&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;NoSQL
전통적인 데이터베이스 RDBMS 보다 덜 제한적인 모델을 이용한다.&lt;/li&gt;
  &lt;li&gt;&lt;/li&gt;
  &lt;li&gt;프로시져&lt;/li&gt;
&lt;/ul&gt;</content><author><name>zangzangs</name></author><category term="interview" /><summary type="html">Database 기술면접 준비</summary></entry><entry><title type="html">[Interview] CS</title><link href="http://localhost:4000/interview-cs" rel="alternate" type="text/html" title="[Interview] CS" /><published>2021-03-12T19:18:00+09:00</published><updated>2021-03-12T19:18:00+09:00</updated><id>http://localhost:4000/interview-cs</id><content type="html" xml:base="http://localhost:4000/interview-cs">&lt;p&gt;#CS 기본 지식 관련
___&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;프로세스와 스레드 차이&lt;/strong&gt;&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;프로세스는 운영체제로부터 자원을 할당받아 실행하고, 스레드는 프로세스로부터 자원을 할당받아 실행&lt;/li&gt;
    &lt;li&gt;하나의 프로세스 안에서 여러 스레드가 생성 가능&lt;/li&gt;
    &lt;li&gt;각 스레드는 개별 스택을 가지고, 프로세스의 전역 메모리 공간을 고유하며 프로그램을 실행
      &lt;ul&gt;
        &lt;li&gt;보통 프로세스는 코드/데이터/스택/힙 메모리 영역을 기반으로 실행한다&lt;/li&gt;
        &lt;li&gt;스레드는 프로세스 안에서, 개별적인 스택을 가지고, 코드/데이터/힙 영역을 공유하며 실행&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;스크립트 언어와 컴파일 언어를 나열하고 차이점을 설명하세요&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;컴파일 언어:C, C++, java 등&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;컴파일언어는 컴파일러를 통해 사전에 컴파일되어 기계어 상태로 실행되므로 실행이 빠름.&lt;/li&gt;
  &lt;li&gt;또한 컴파일 단계에서 전체 코드를 기계어로 변환할 때, 최적화작업을 진행하여 실행 시간을 보다 빠르게 할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;스트립트 언어:: python, javascript, ruby 등&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;스트립트 언어는 컴파일 단계 없이 실행 단계에서 한 줄씩 기계어로 번역 후 실행되므로 통상 컴파일 언어보다 실행이 느리다.&lt;/li&gt;
  &lt;li&gt;전체 코드에 대한 실행 코드 최적화가 어려움&lt;/li&gt;
&lt;/ul&gt;</content><author><name>zangzangs</name></author><category term="interview" /><summary type="html">#CS 기본 지식 관련 ___</summary></entry><entry><title type="html">커넥션 풀을 관리하는 방법, DBCP와 JNDI</title><link href="http://localhost:4000/dbcp-vs-jndi" rel="alternate" type="text/html" title="커넥션 풀을 관리하는 방법, DBCP와 JNDI" /><published>2021-03-12T19:18:00+09:00</published><updated>2021-03-12T19:18:00+09:00</updated><id>http://localhost:4000/dbcp-vs-jndi</id><content type="html" xml:base="http://localhost:4000/dbcp-vs-jndi">&lt;p&gt;다음 프로젝트 준비를 하다가 커넥션 풀을 DBCP에서 JNDI로 변경한다는 이야기를 들었습니다. 커넥션 풀에 대해서는 알고 있었지만 DBCP와 JNDI에 대해서는 처음 듣는 단어라 생소하여 해당 내용을 찾아봤습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;커넥션-풀connection-pool이란&quot;&gt;커넥션 풀(connection pool)이란&lt;/h2&gt;

&lt;p&gt;JAVA에서는 JDBC를 사용해서 커넥션을 생성합니다. 그리고 커넥션 풀은 생성된 커넥션을 관리합니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;JDBC&lt;/strong&gt;( &lt;strong&gt;Java Database Connectivity&lt;/strong&gt; )는 자바에서 데이터베이스에 접속할 수 있도록 하는 &lt;strong&gt;자바 표준 API&lt;/strong&gt;이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;데이터베이스와 연결된 Connection을 미리 만들어서 pool 속에 저장해 두고 있다가 필요할 때 Connection을 Pool에서 쓰고 다시 Pool에 반환하는 기법을 말합니다.&lt;/p&gt;

&lt;p&gt;Pool 속에 미리 Connection이 생성되어 있기 때문에 Connection을 생성하는 시간이 소비되지 않습니다. Connection을 계속해서 재사용하기 때문에 많은 수의 Connection을 만들지는 않습니다. 
Connection Pool을 사용하면 Connection을 생성하고 닫는 시간이 소모되지 않기 때문에 그만큼 애플리케이션의 실행 속도가 빨라집니다.&lt;/p&gt;

&lt;p&gt;한 번에 생성될 수 있는 Connection 수를 제어하기 때문에 동시 접속자 수가 몰려도 애플리케이션이 쉽게 다운되지 않습니다.&lt;/p&gt;

&lt;p&gt;Connection Pool에서 생성된 Connection의 개수는 한정적입니다. 동시 접속자가 많아 남아 있는 Connection이 없으면 해당 클라이언트는 대기 상태로 전환이 되고, Connection이 반환되면 대기하고 있는 순서대로 Connection이 제공됩니다.
&lt;br /&gt;&lt;/p&gt;
&lt;div style=&quot;text-align:center;&quot;&gt;
    &lt;img src=&quot;/assets/images/java/connection-pool.png&quot; alt=&quot;커넥션 풀&quot; style=&quot;zoom:50%;&quot; /&gt;
&lt;/div&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;커넥션을 관리하는 것은 애플리케이션을 운영하는데 매우 중요합니다. DBCP와 JNDI는 이러한 커넥션 풀을 효율적으로 관리하기 위한 방법입니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;dbcpdatabase-connection-pool&quot;&gt;DBCP(Database Connection Pool)&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;데이터베이스  Connection을 &lt;strong&gt;애플리케이션&lt;/strong&gt;에서 제어하면서 하나의 커넥션 풀을 가진다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;데이터베이스 애플리케이션을 효율적으로 연결하는 커넥션 풀 라이브러리는 웹 애플리케이션에서는 필수 요소입니다. 웹 애플리케이션 서버로 상용 제품을 사용한다면 보통 제조사에서 제공하는 커넥션 풀 구현체를 사용합니다. 그 외에 오픈소스 라이브러리로 Apache의 Commons DBCP와 Tomcat-JDBC, BoneCP, HikariCP 등이 있습니다.&lt;/p&gt;

&lt;p&gt;웹 애플리케이션의 요청은 대부분 DBMS를 사용되기 때문에 커넥션 풀 라이브러리의 설정은 전체 애플리케이션의 성능과 안정성에 영향을 미치는 &lt;strong&gt;핵심&lt;/strong&gt; 입니다.&lt;/p&gt;

&lt;h4 id=&quot;특징&quot;&gt;특징&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;데이터베이스와 애플리케이션의 일부분에서 발생하는 문제가 전체로 전파되지 않는다.&lt;/li&gt;
  &lt;li&gt;일시적인 문제가 긴 시간 이어지지 않게 한다.&lt;/li&gt;
  &lt;li&gt;값을 적절하지 못하게 설정해서 커넥션 풀이 애플리케이션에서 병목 지점이 되기도 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;jndijava-naming-and-directory-interface&quot;&gt;JNDI(Java Naming and Directory Interface)&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;데이터베이스  Connection을 &lt;strong&gt;WAS Server&lt;/strong&gt;에서 제어하면서 하나의 커넥션 풀을 가진다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;JNDI는 디렉터리 서비스에서 제공하는 데이터 및 객체를 발견(discover)하고 참고(lookup)하기 위한 자바 API입니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;특징-1&quot;&gt;특징&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;데이터베이스 설정 정보를 관리가 쉽다.&lt;/li&gt;
  &lt;li&gt;애플리케이션 레벨에서 데이터베이스 Connection에 필요한 설정 정보들을 설정해 놓는다.&lt;/li&gt;
  &lt;li&gt;애플리케이션은 하나이더라도 여러 종류의 데이터베이스를 사용할 수 있다는 점에서 해당 애플리케이션 개발자가 아니라면 정보를 찾는데 꽤나 시간이 걸린다.&lt;/li&gt;
  &lt;li&gt;JNDI를 사용하게 되면 DB Connection 정보를 일반 개발자에게 노출되지 않아 보안상의 이점이 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;결론&quot;&gt;결론&lt;/h2&gt;
&lt;p&gt;두가지 방식 모두 장단점이 있습니다. 꼭 어떤 방식이 좋고 나쁘다가 아니라 목적에 적합한 방법을 사용하면 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;refference&quot;&gt;Refference&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://d2.naver.com/helloworld/1321&quot;&gt;https://d2.naver.com/helloworld/1321&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://eongeuni.tistory.com/43&quot;&gt;https://eongeuni.tistory.com/43&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://zunoxi.github.io/infra/2020/06/20/infra-db-jdbc/&quot;&gt;https://zunoxi.github.io/infra/2020/06/20/infra-db-jdbc/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>zangzangs</name></author><category term="java" /><category term="spring" /><summary type="html">다음 프로젝트 준비를 하다가 커넥션 풀을 DBCP에서 JNDI로 변경한다는 이야기를 들었습니다. 커넥션 풀에 대해서는 알고 있었지만 DBCP와 JNDI에 대해서는 처음 듣는 단어라 생소하여 해당 내용을 찾아봤습니다.</summary></entry></feed>