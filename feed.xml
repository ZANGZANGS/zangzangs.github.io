<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.7.4">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2021-03-20T12:22:32+09:00</updated><id>http://localhost:4000/</id><title type="html">장장스 블로그</title><subtitle>Backend Developer</subtitle><entry><title type="html">[OS] 운영체제 개요</title><link href="http://localhost:4000/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EA%B0%9C%EC%9A%94" rel="alternate" type="text/html" title="[OS] 운영체제 개요" /><published>2021-03-13T10:00:00+09:00</published><updated>2021-03-13T10:00:00+09:00</updated><id>http://localhost:4000/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%20%EA%B0%9C%EC%9A%94</id><content type="html" xml:base="http://localhost:4000/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EA%B0%9C%EC%9A%94">&lt;h1 id=&quot;운영체제-개요&quot;&gt;운영체제 개요&lt;/h1&gt;
&lt;hr /&gt;

&lt;h3 id=&quot;운영체제의-정의&quot;&gt;운영체제의 정의&lt;/h3&gt;
&lt;p&gt;하드웨어 바로 위에 설치되어 사용자 및 다른 모든 소프트웨어와 하드웨어를 연결하는 소프트웨어 계층&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;center&gt;
&lt;img src=&quot;./../../_images/operating_system/운영체제의%20위상.png&quot; width=&quot;70%&quot; height=&quot;70%&quot; /&gt;
&lt;/center&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;운영체제의-기능&quot;&gt;운영체제의 기능&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;자원을 효율적으로 관리한다.
    &lt;ul&gt;
      &lt;li&gt;효율성: 효율적이나 일부가 지나치게 희생되지 않도록&lt;/li&gt;
      &lt;li&gt;형평성: 프로그램들 간의 자원을 형평성 있게 분배&lt;/li&gt;
      &lt;li&gt;보안 및 보호&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;사용자 및 운영체제 자신의 보호한다.&lt;/li&gt;
  &lt;li&gt;프로세스, 파일, 메시지 등을 관리한다.&lt;/li&gt;
  &lt;li&gt;컴퓨터 시스템을 편리하게 사용할 수 있는 환경을 제공한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;운영체제의-분류&quot;&gt;운영체제의 분류&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;동시 작업 가능 여부
    &lt;ul&gt;
      &lt;li&gt;단일작업(single tasking)&lt;/li&gt;
      &lt;li&gt;다중작업(multi tasking)&lt;span style=&quot;color:red&quot;&gt; ✓pick&lt;/span&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;사용자 수
    &lt;ul&gt;
      &lt;li&gt;단일 사용자&lt;/li&gt;
      &lt;li&gt;다중 사용자&lt;span style=&quot;color:red&quot;&gt; ✓pick&lt;/span&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;처리방식
    &lt;ul&gt;
      &lt;li&gt;일괄처리 방식(batch processing)&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;시분할 방식(time sharing system)&lt;/strong&gt;&lt;span style=&quot;color:red&quot;&gt; ✓pick&lt;/span&gt;&lt;/li&gt;
      &lt;li&gt;실시간(real time)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h3 id=&quot;운영-체제의-자원-관리-기능&quot;&gt;운영 체제의 자원 관리 기능&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;CPU 스케쥴링(CPU scheduling)&lt;/strong&gt;
CPU를 가장 효율적으로 사용하면서도, 특정 프로세스가 불이익을 당하지 않도록 하는 것
    &lt;ul&gt;
      &lt;li&gt;선입선출
CPU를 사용하기 위해 도착한 프로세스들 중 먼저 온 것을 먼저 처리해주는 방식&lt;/li&gt;
      &lt;li&gt;라운드 로빈(Round Robin)&lt;span style=&quot;color:red&quot;&gt; ✓pick&lt;/span&gt;
CPU를 한 번 할당받아 사용할 수 있는 시간을 일정하게 고정된 시간으로 제한한다.&lt;/li&gt;
      &lt;li&gt;우선순위
대기 중인 프로세스들에 우선순위를 부여하고 우선순위가 높은 프로세스에 CPU를 먼저 할당한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;메모리 관리&lt;/strong&gt;
물리적 메모리를 관리하는 방식
    &lt;ul&gt;
      &lt;li&gt;고정분할 방식(fixed partition)
        &lt;ul&gt;
          &lt;li&gt;물리적 메모리를 일정 개수로 분할 하여 사용하는 방식을 말한다.&lt;/li&gt;
          &lt;li&gt;단점으로 분할 개수만큼만 프로그램을 사용할 수 있으며, 분할된 메모리보다 큰 프로그램은 적재가 불가능하다.&lt;/li&gt;
          &lt;li&gt;분할된 메모리보다 적은 메모리를 사용하는 프로그램이 적재가 되면 남는 메모리영역이 발생하는데 이를 &lt;span style=&quot;color:blue&quot;&gt;내부조각(internal fragment)&lt;/span&gt; 이라고 한다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;가변분할 방식(variable partition)
        &lt;ul&gt;
          &lt;li&gt;프로그램 크기에 맞게 메모리를 분할해서 사용하는 방식을 말한다.&lt;/li&gt;
          &lt;li&gt;메모리가 일정부분 20이 남았다고 했을 때, 40의 메모리를 가진 프로그램을 적재할 수 없어 남는 메모리 영역이 발생한다. 이를 &lt;span style=&quot;color:blue&quot;&gt;외부조각(external fragment)&lt;/span&gt;이라고 한다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;가상메모리(virtual memory)&lt;span style=&quot;color:red&quot;&gt; ✓pick&lt;/span&gt;
        &lt;ul&gt;
          &lt;li&gt;물리적 메모리보다 더 큰 프로그램이 실행되는 것을 지원한다.&lt;/li&gt;
          &lt;li&gt;현재 사용되고 있는 부분만 메모리에 올리고, 나머지는 하드디스크와 같은 보조기억장치에 저장해두었다가 필요할 때 적재하는 방식을 취한다. 이떄 사용되는 보조기억장치의 영역을 &lt;span style=&quot;color:blue&quot;&gt;스왑 영역(swap area)&lt;/span&gt;이라고 부른다.&lt;/li&gt;
          &lt;li&gt;가상메모리 주소 공간은 페이지(page)라는 동일한 크기의 작은 단위로 나뉘어 물리적 메모리와 스왑 영역에 일부분씩 저장된다. 이렇게 동일한 단위로 메모리를 나누는 기업을 &lt;span style=&quot;color:blue&quot;&gt;페이징(paging) 기법&lt;/span&gt;이라고 한다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;주변장치 및 입출력 관리&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;인터럽트
        &lt;ul&gt;
          &lt;li&gt;주변장치들이 CPU의 서비스가 필요한 경우 보내는 신호&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;컨트롤러
        &lt;ul&gt;
          &lt;li&gt;주변장치들이 메인 CPU에 인터럽트를 발생시켜 보고하는 역할&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;메모리에 존재하는 OS의 최소한의&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;
&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;/p&gt;</content><author><name>zangzangs</name></author><category term="os" /><summary type="html">운영체제 개요</summary></entry><entry><title type="html">[Interview] JAVA</title><link href="http://localhost:4000/interview-java" rel="alternate" type="text/html" title="[Interview] JAVA" /><published>2021-03-12T19:18:00+09:00</published><updated>2021-03-12T19:18:00+09:00</updated><id>http://localhost:4000/interview-java</id><content type="html" xml:base="http://localhost:4000/interview-java">&lt;h1 id=&quot;java-interview&quot;&gt;Java Interview&lt;/h1&gt;
&lt;hr /&gt;
&lt;blockquote&gt;
  &lt;p&gt;java의 장단점&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;장점
      &lt;ul&gt;
        &lt;li&gt;운영체제에 독립적이다.
          &lt;ul&gt;
            &lt;li&gt;JVM에서 동작하기 때문에, 특적 운영체제에 종속되지 않는다.&lt;/li&gt;
          &lt;/ul&gt;
        &lt;/li&gt;
        &lt;li&gt;객체지향 언어이다.&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;</content><author><name>zangzangs</name></author><category term="interview" /><summary type="html">Java Interview java의 장단점 장점 운영체제에 독립적이다. JVM에서 동작하기 때문에, 특적 운영체제에 종속되지 않는다. 객체지향 언어이다.</summary></entry><entry><title type="html">[Interview] 데이터베이스</title><link href="http://localhost:4000/interview-database" rel="alternate" type="text/html" title="[Interview] 데이터베이스" /><published>2021-03-12T19:18:00+09:00</published><updated>2021-03-12T19:18:00+09:00</updated><id>http://localhost:4000/interview-database</id><content type="html" xml:base="http://localhost:4000/interview-database">&lt;h3 id=&quot;database-기술면접-준비&quot;&gt;Database 기술면접 준비&lt;/h3&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;-트랜잭션&quot;&gt;| 트랜잭션&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;데이터베이스 내에 하나의 그룹으로 처리해야하는 명령문을 모아놓은 작업단위 또는 데이터 처리의 한 단위&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;-acid-트랜잭션의-특징&quot;&gt;| ACID, 트랜잭션의 특징&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Atomicity (원자성) 
트랜잭션과 관련된 일은 모두 실행되던지 모두 실행되지 않도록 하던지를 보장하는 특성이다.&lt;/li&gt;
  &lt;li&gt;Consistency (일관성)
 트랜잭션이 성공했다면, 데이터베이스는 그 일관성을 유지해야 한다. 일관성은 특정한 조건을 두고, 그 조건을 만족하는지를 확인하는 방식으로 검사할 수 있다.&lt;/li&gt;
  &lt;li&gt;Isolation (독립성)
독립성. 트랜잭션을 수행하는 도중에 다른 연산작업이 끼어들지 못하도록 한다. 임계영역을 두는 것으로 달성할 수 있다.&lt;/li&gt;
  &lt;li&gt;Durability (지속성)
성공적으로 트랜잭션이 수행되었다면, 그 결과는 완전히 반영이 되어야 한다. 완전히 반영되면 로그를 남기게 되는데, 후에 이 로그를 이용해서 트랜잭션 수행전 상태로 되돌릴 수 있어야 한다. 때문에 트랜잭션은 로그저장이 완료된 시점에서 종료가 되어야 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;데이터베이스-언어의-종류-3가지&quot;&gt;데이터베이스 언어의 종류 3가지&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;DDL(Data Definition Language)
데이터베이스를 정의하는 언어이며, 데이터리를 생성, 수정, 삭제하는 등의 데이터의 전체의 골격을 결정하는 역할을 하는 언어 입니다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th&gt;종류&lt;/th&gt;
          &lt;th&gt;역할&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;CREATE&lt;/td&gt;
          &lt;td&gt;데이터베이스, 테이블 등을 생성하는 역할을 합니다.&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;ALTER&lt;/td&gt;
          &lt;td&gt;테이블을 수정하는 역할을 합니다.&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;DROP&lt;/td&gt;
          &lt;td&gt;데이터베이스,테이블을 삭제&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;RENAME&lt;/td&gt;
          &lt;td&gt;데이터베이스의 객체 이름을 변경&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;COMMENT&lt;/td&gt;
          &lt;td&gt;데이터에 주석 등을 추가한다.&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;TRUNCATE&lt;/td&gt;
          &lt;td&gt;테이블을 초기화 한다&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;DML(Data Manipulation Language)
정의된 데이터베이스에 입력된 레코드를 조회하거나 수정하거나 삭제하는 등의 역할을 하는 언어를 말합니다.
|종류|역할|
|—|—|
|SELECT|데이터를 조회하는 명령어|
|INSERT|데이터 삽입하는 명령어|
|UPDATE| 데이터를 수정하는 명령어|
|DELETE|데이터를 삭제하는 명령어|
|MERGE|데이터가 테이블에 없으면 INSERT, 있다면 UPDATE를 수행한다. UPSERT 라는 별명이 있다.|&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;DCL(Data Control Language)
데이터베이스에 접근하거나 객체에 권한을 주는등의 역할을 하는 언어를 입니다.
|종류|역할|
|—|—|
|GRANT|특정 데이터베이스 사용자에게 특정 작업에 대한 수행권한을 부여|
|REVOKE|특정 데이터베이스 사용자에게 특정 작업에 대한 수행 권한을 박탈, 회수|&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;TCL(Transaction Control Language)
데이터의 보안, 무결성, 회복, 병행 수행제어 등을 제어하는 역할을 하는 언어입니다.&lt;/p&gt;

    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
          &lt;th&gt;종류&lt;/th&gt;
          &lt;th&gt;역할&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;COMMIT&lt;/td&gt;
          &lt;td&gt;트랜잭션의 작업 결과를 저장 반영한다.&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;ROLLBACK&lt;/td&gt;
          &lt;td&gt;데이터베이스를 마지막 COMMIT 시점으로 복원&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;SAVEPOIN&lt;/td&gt;
          &lt;td&gt;ROOLBACK시 저장위치까지 트랜잭션의 일부만 롤백 할 수 있다.&lt;/td&gt;
        &lt;/tr&gt;
        &lt;tr&gt;
          &lt;td&gt;SET TRANSACTION&lt;/td&gt;
          &lt;td&gt;transaction 지정&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;오라클 힌트 (Oracle Hint)
오라클 옵티마이저에게 SQL문 실행을 위한 데이터를 스캐닝하는 경로, 조인하는 방법 등을 알려주기 위해 SQL 작성자가 직접 작성해주는 구문이다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;옵티마이저란?&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;정규화&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;튜플&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;카디널리티&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;JOIN&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;GROUP BY, HAVING&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;NoSQL
전통적인 데이터베이스 RDBMS 보다 덜 제한적인 모델을 이용한다.&lt;/li&gt;
  &lt;li&gt;&lt;/li&gt;
  &lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>zangzangs</name></author><category term="interview" /><summary type="html">Database 기술면접 준비</summary></entry><entry><title type="html">[Interview] CS</title><link href="http://localhost:4000/interview-cs" rel="alternate" type="text/html" title="[Interview] CS" /><published>2021-03-12T19:18:00+09:00</published><updated>2021-03-12T19:18:00+09:00</updated><id>http://localhost:4000/interview-cs</id><content type="html" xml:base="http://localhost:4000/interview-cs">&lt;p&gt;#CS 기본 지식 관련
___&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;프로세스와 스레드 차이&lt;/strong&gt;&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;프로세스는 운영체제로부터 자원을 할당받아 실행하고, 스레드는 프로세스로부터 자원을 할당받아 실행&lt;/li&gt;
    &lt;li&gt;하나의 프로세스 안에서 여러 스레드가 생성 가능&lt;/li&gt;
    &lt;li&gt;각 스레드는 개별 스택을 가지고, 프로세스의 전역 메모리 공간을 고유하며 프로그램을 실행
      &lt;ul&gt;
        &lt;li&gt;보통 프로세스는 코드/데이터/스택/힙 메모리 영역을 기반으로 실행한다&lt;/li&gt;
        &lt;li&gt;스레드는 프로세스 안에서, 개별적인 스택을 가지고, 코드/데이터/힙 영역을 공유하며 실행&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;스크립트 언어와 컴파일 언어를 나열하고 차이점을 설명하세요&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;컴파일 언어:C, C++, java 등&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;컴파일언어는 컴파일러를 통해 사전에 컴파일되어 기계어 상태로 실행되므로 실행이 빠름.&lt;/li&gt;
  &lt;li&gt;또한 컴파일 단계에서 전체 코드를 기계어로 변환할 때, 최적화작업을 진행하여 실행 시간을 보다 빠르게 할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;스트립트 언어:: python, javascript, ruby 등&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;스트립트 언어는 컴파일 단계 없이 실행 단계에서 한 줄씩 기계어로 번역 후 실행되므로 통상 컴파일 언어보다 실행이 느리다.&lt;/li&gt;
  &lt;li&gt;전체 코드에 대한 실행 코드 최적화가 어려움&lt;/li&gt;
&lt;/ul&gt;</content><author><name>zangzangs</name></author><category term="interview" /><summary type="html">#CS 기본 지식 관련 ___</summary></entry><entry><title type="html">커넥션 풀을 관리하는 방법, DBCP와 JNDI</title><link href="http://localhost:4000/dbcp-vs-jndi" rel="alternate" type="text/html" title="커넥션 풀을 관리하는 방법, DBCP와 JNDI" /><published>2021-03-12T19:18:00+09:00</published><updated>2021-03-12T19:18:00+09:00</updated><id>http://localhost:4000/dbcp-vs-jndi</id><content type="html" xml:base="http://localhost:4000/dbcp-vs-jndi">&lt;p&gt;다음 프로젝트 준비를 하다가 커넥션 풀을 DBCP에서 JNDI로 변경한다는 이야기를 들었습니다. 커넥션 풀에 대해서는 알고 있었지만 DBCP와 JNDI에 대해서는 처음 듣는 단어라 생소하여 해당 내용을 찾아봤습니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;커넥션-풀connection-pool이란&quot;&gt;커넥션 풀(connection pool)이란&lt;/h2&gt;

&lt;p&gt;JAVA에서는 JDBC를 사용해서 커넥션을 생성합니다. 그리고 커넥션 풀은 생성된 커넥션을 관리합니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;JDBC&lt;/strong&gt;( &lt;strong&gt;Java Database Connectivity&lt;/strong&gt; )는 자바에서 데이터베이스에 접속할 수 있도록 하는 &lt;strong&gt;자바 표준 API&lt;/strong&gt;이다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;데이터베이스와 연결된 Connection을 미리 만들어서 pool 속에 저장해 두고 있다가 필요할 때 Connection을 Pool에서 쓰고 다시 Pool에 반환하는 기법을 말합니다.&lt;/p&gt;

&lt;p&gt;Pool 속에 미리 Connection이 생성되어 있기 때문에 Connection을 생성하는 시간이 소비되지 않습니다. Connection을 계속해서 재사용하기 때문에 많은 수의 Connection을 만들지는 않습니다. 
Connection Pool을 사용하면 Connection을 생성하고 닫는 시간이 소모되지 않기 때문에 그만큼 애플리케이션의 실행 속도가 빨라집니다.&lt;/p&gt;

&lt;p&gt;한 번에 생성될 수 있는 Connection 수를 제어하기 때문에 동시 접속자 수가 몰려도 애플리케이션이 쉽게 다운되지 않습니다.&lt;/p&gt;

&lt;p&gt;Connection Pool에서 생성된 Connection의 개수는 한정적입니다. 동시 접속자가 많아 남아 있는 Connection이 없으면 해당 클라이언트는 대기 상태로 전환이 되고, Connection이 반환되면 대기하고 있는 순서대로 Connection이 제공됩니다.
&lt;br /&gt;&lt;/p&gt;
&lt;center&gt;
&lt;img src=&quot;/assets/images/java/connection-pool.png&quot; alt=&quot;커넥션 풀&quot; style=&quot;zoom:50%;&quot; /&gt;
&lt;/center&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;커넥션을 관리하는 것은 애플리케이션을 운영하는데 매우 중요합니다. DBCP와 JNDI는 이러한 커넥션 풀을 효율적으로 관리하기 위한 방법입니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;dbcpdatabase-connection-pool&quot;&gt;DBCP(Database Connection Pool)&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;데이터베이스  Connection을 &lt;strong&gt;애플리케이션&lt;/strong&gt;에서 제어하면서 하나의 커넥션 풀을 가진다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;데이터베이스 애플리케이션을 효율적으로 연결하는 커넥션 풀 라이브러리는 웹 애플리케이션에서는 필수 요소입니다. 웹 애플리케이션 서버로 상용 제품을 사용한다면 보통 제조사에서 제공하는 커넥션 풀 구현체를 사용합니다. 그 외에 오픈소스 라이브러리로 Apache의 Commons DBCP와 Tomcat-JDBC, BoneCP, HikariCP 등이 있습니다.&lt;/p&gt;

&lt;p&gt;웹 애플리케이션의 요청은 대부분 DBMS를 사용되기 때문에 커넥션 풀 라이브러리의 설정은 전체 애플리케이션의 성능과 안정성에 영향을 미치는 &lt;strong&gt;핵심&lt;/strong&gt; 입니다.&lt;/p&gt;

&lt;h4 id=&quot;특징&quot;&gt;특징&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;데이터베이스와 애플리케이션의 일부분에서 발생하는 문제가 전체로 전파되지 않는다.&lt;/li&gt;
  &lt;li&gt;일시적인 문제가 긴 시간 이어지지 않게 한다.&lt;/li&gt;
  &lt;li&gt;값을 적절하지 못하게 설정해서 커넥션 풀이 애플리케이션에서 병목 지점이 되기도 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;jndijava-naming-and-directory-interface&quot;&gt;JNDI(Java Naming and Directory Interface)&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;데이터베이스  Connection을 &lt;strong&gt;WAS Server&lt;/strong&gt;에서 제어하면서 하나의 커넥션 풀을 가진다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;JNDI는 디렉터리 서비스에서 제공하는 데이터 및 객체를 발견(discover)하고 참고(lookup)하기 위한 자바 API입니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h4 id=&quot;특징-1&quot;&gt;특징&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;데이터베이스 설정 정보를 관리가 쉽다.&lt;/li&gt;
  &lt;li&gt;애플리케이션 레벨에서 데이터베이스 Connection에 필요한 설정 정보들을 설정해 놓는다.&lt;/li&gt;
  &lt;li&gt;애플리케이션은 하나이더라도 여러 종류의 데이터베이스를 사용할 수 있다는 점에서 해당 애플리케이션 개발자가 아니라면 정보를 찾는데 꽤나 시간이 걸린다.&lt;/li&gt;
  &lt;li&gt;JNDI를 사용하게 되면 DB Connection 정보를 일반 개발자에게 노출되지 않아 보안상의 이점이 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;결론&quot;&gt;결론&lt;/h2&gt;
&lt;p&gt;두가지 방식 모두 장단점이 있습니다. 꼭 어떤 방식이 좋고 나쁘다가 아니라 목적에 적합한 방법을 사용하면 됩니다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;h3 id=&quot;refference&quot;&gt;Refference&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://d2.naver.com/helloworld/1321&quot;&gt;https://d2.naver.com/helloworld/1321&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://eongeuni.tistory.com/43&quot;&gt;https://eongeuni.tistory.com/43&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://zunoxi.github.io/infra/2020/06/20/infra-db-jdbc/&quot;&gt;https://zunoxi.github.io/infra/2020/06/20/infra-db-jdbc/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>zangzangs</name></author><category term="java" /><category term="spring" /><summary type="html">다음 프로젝트 준비를 하다가 커넥션 풀을 DBCP에서 JNDI로 변경한다는 이야기를 들었습니다. 커넥션 풀에 대해서는 알고 있었지만 DBCP와 JNDI에 대해서는 처음 듣는 단어라 생소하여 해당 내용을 찾아봤습니다.</summary></entry></feed>