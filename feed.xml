<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2021-06-15T22:45:25+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Your awesome title</title><subtitle>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.</subtitle><author><name>GitHub User</name></author><entry><title type="html">[운영체제] (6) 병행제어</title><link href="http://localhost:4000/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/2021/05/26/os06.html" rel="alternate" type="text/html" title="[운영체제] (6) 병행제어" /><published>2021-05-26T19:18:00+09:00</published><updated>2021-05-26T19:18:00+09:00</updated><id>http://localhost:4000/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/2021/05/26/os06</id><content type="html" xml:base="http://localhost:4000/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/2021/05/26/os06.html">&lt;h2 id=&quot;race-condition&quot;&gt;Race Condition&lt;/h2&gt;

&lt;p&gt;하나의 Storage에 다수가 접근하는 경우 발생한다.&lt;/p&gt;

&lt;h3 id=&quot;언제-발생하는가&quot;&gt;언제 발생하는가?&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;커널 수행 중 인터럽트 발생 시&lt;/li&gt;
&lt;/ol&gt;

&lt;div style=&quot;text-align:center;&quot;&gt;
  &lt;img src=&quot;/assets/images/operating_system/race%20condition%20ex1.png&quot; style=&quot;zoom:110%&quot; /&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;해결 방법
    &lt;ul&gt;
      &lt;li&gt;커널 수행 중에 인터럽트 처리 못하게 disable 한다. 커널 수행이 끝난 후 인터럽트 처리를 enable 하게 변경한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;프로세스가 시스템콜을 하여 커널 모드로 수행 중인데 문맥교환이 일어나는 경우&lt;/li&gt;
&lt;/ol&gt;

&lt;div style=&quot;text-align:center;&quot;&gt;
  &lt;img src=&quot;/assets/images/operating_system/race%20condition%20ex2.png&quot; style=&quot;zoom:110%&quot; /&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;해결방법
    &lt;ul&gt;
      &lt;li&gt;커널 모드에서 수행 중일 때는 CPU를 점유하지 못하도록 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;멀티프로세서에서 공유 메모리 내의 커널 데이타를 사용하는 경우&lt;/li&gt;
&lt;/ol&gt;

&lt;div style=&quot;text-align:center;&quot;&gt;
  &lt;img src=&quot;/assets/images/operating_system/race%20condition%20ex3.png&quot; style=&quot;zoom:110%&quot; /&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;해결방법
    &lt;ul&gt;
      &lt;li&gt;멀티프로세서의 경우 인터럽트를 enable/disable 하는 것으로 해결이 되지 않는다.&lt;/li&gt;
      &lt;li&gt;방법1. 한번에 하나의 CPU만 커널에 들어가게 한다&lt;/li&gt;
      &lt;li&gt;방법2. 커널 내부에 있는 각 공유 데이터에 접근할 때마다 그 데이터에 대한 lock/unlock을 하는 방법&lt;/li&gt;
      &lt;li&gt;방법 1처럼 운영체제 자체를 접근못하게 막으면 오베헤드가 너무 커지는 문제가 있다. 이와 같은 문제를 해결하기 위해 방법 2와 같이 lock을 걸어 해결할 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;프로세스-동기화-문제&quot;&gt;프로세스 동기화 문제&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;공유데이터의 동시 접근은 데이터의 불일치 문제를 발생시킬 수 있다&lt;/li&gt;
  &lt;li&gt;일관성 유지를 위해서는 협력 프로세스 간의 실행 순서를 정해주는 메커니즘 필요&lt;/li&gt;
  &lt;li&gt;레이스 컨디션
    &lt;ul&gt;
      &lt;li&gt;여러 프로세스들이 동시에 공유 데이터를 접근하는 상황&lt;/li&gt;
      &lt;li&gt;데이터의 최종 연산 결과는 마지막에 그 데이터를 다룬 프로세스에 따라 달라짐&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;레이스 컨디션을 막기 위해서는 concurrent process는 동기화되어야 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;## Critical-Section Problem&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;n 개의 프로세스가 공유 데이터를 동시에 사용하기를 원하는 경우&lt;/li&gt;
  &lt;li&gt;각 프로세스의 code segment에는 공유 데이터를 접근하는 코드인 critical section이 존재&lt;/li&gt;
  &lt;li&gt;Problem
    &lt;ul&gt;
      &lt;li&gt;하나의 프로세스가 critical section에 있을 때 다른 모든 프로세스는 critical section에 들어갈 수 없어야 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;프로그램적-해결법의-충족-조건&quot;&gt;프로그램적 해결법의 충족 조건&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;상호 배제 (Mutual Exclusion)&lt;/li&gt;
  &lt;li&gt;진행 (Progress)&lt;/li&gt;
  &lt;li&gt;유한대기 (Bounded Waiting)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;synchronization-hardware&quot;&gt;Synchronization Hardware&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;하드웨어적으로 Test &amp;amp; modify를 atomic하게 수행할 수 있도록 지원하는 경우 앞의 문제는 간단히 해결&lt;/li&gt;
&lt;/ul&gt;</content><author><name>zangzangs</name></author><category term="운영체제" /><category term="os" /><summary type="html">Race Condition</summary></entry><entry><title type="html">뷰 엑시오스(Axios) 메서드와 옵션</title><link href="http://localhost:4000/2021/05/01/vue-%EC%97%91%EC%8B%9C%EC%98%A4%EC%8A%A4.html" rel="alternate" type="text/html" title="뷰 엑시오스(Axios) 메서드와 옵션" /><published>2021-05-01T20:11:00+09:00</published><updated>2021-05-01T20:11:00+09:00</updated><id>http://localhost:4000/2021/05/01/vue-%EC%97%91%EC%8B%9C%EC%98%A4%EC%8A%A4</id><content type="html" xml:base="http://localhost:4000/2021/05/01/vue-%EC%97%91%EC%8B%9C%EC%98%A4%EC%8A%A4.html">&lt;h2 id=&quot;액시오스axios&quot;&gt;액시오스(Axios)&lt;/h2&gt;
&lt;p&gt;http 통신을 하기 위한 라이브러리로 Promise 기반의 API형식이 다양하게 제공된다. 따라서 별도의 로직을 구현할 필요 없이 주어진 API만으로도 간편하게 원하는 로직을 구현할 수 있습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;promise 기반의 API 형식&lt;/strong&gt;
Pormise란 서버에 데이터를 요청하여 받아오는 동작과 같은 비동기 로직 처리에 유용한 javascript 객체입니다. javascript는 단일 스레드로 코드를 처리하기 때문에 특정 로직의 처리가 끝날 때까지 기다려주지 않습니다. 따라서 데이터를 요청하고 받아올 때까지 기다렸다가 화면에 나타내는 로직을 실행해야 할 때 주로 Promise를 활용합니다. 그리고 데이터를 받아왔을 때 Promise로 데이터를 화면에  표시하거나 연산을 수행하는 등 특정 로직을 수행합니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;뷰 리소스&lt;/strong&gt;
엑시오스와 마찬가지로 http 통신을 위한 라이브러리이다. 엑시오스에 이어 두 번째로 많이 사용되고 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;액시오스-request-methods&quot;&gt;액시오스 Request methods&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;axios.post('/user', {
    firstName: 'Fred',
    lastName: 'Flintstone'
  })
  .then(function (response) {
    console.log(response);
  })
  .catch(function (error) {
    console.log(error);
  });
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;옵션&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;axios.request(config)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;axios.get(url[, config])&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;axios.delete(url[, config])&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;axios.head(url[, config])&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;axios.options(url[, config])&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;axios.post(url[, data[, config]])&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;axios.put(url[, data[, config]])&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;axios.patch(url[, data[, config]])&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;config-옵션&quot;&gt;Config 옵션&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{
  url: '/user',
  method: 'get', // default
  baseURL: 'https://some-domain.com/api/',
  transformRequest: [function (data, headers) {
    // Do whatever you want to transform the data
    return data;
  }],
  transformResponse: [function (data) {
    // Do whatever you want to transform the data
    return data;
  }],
  headers: {'X-Requested-With': 'XMLHttpRequest'},
  params: {
    ID: 12345
  },
  paramsSerializer: function (params) {
    return Qs.stringify(params, {arrayFormat: 'brackets'})
  },
  data: {
    firstName: 'Fred'
  },
  timeout: 1000, // default is `0` (no timeout)
  withCredentials: false, // default
  adapter: function (config) {
    /* ... */
  },
  auth: {
    username: 'janedoe',
    password: 's00pers3cret'
  },
  responseType: 'json', // default
  responseEncoding: 'utf8', // default
  xsrfCookieName: 'XSRF-TOKEN', // default
  xsrfHeaderName: 'X-XSRF-TOKEN', // default
  onUploadProgress: function (progressEvent) {
    // Do whatever you want with the native progress event
  },
  onDownloadProgress: function (progressEvent) {
    // Do whatever you want with the native progress event
  },
  maxContentLength: 2000,
  maxBodyLength: 2000,
  validateStatus: function (status) {
    return status &amp;gt;= 200 &amp;amp;&amp;amp; status &amp;lt; 300; // default
  },
  maxRedirects: 5, // default
  socketPath: null, // default
  httpAgent: new http.Agent({ keepAlive: true }),
  httpsAgent: new https.Agent({ keepAlive: true }),
  proxy: {
    protocol: 'https',
    host: '127.0.0.1',
    port: 9000,
    auth: {
      username: 'mikeymike',
      password: 'rapunz3l'
    }
  },
  cancelToken: new CancelToken(function (cancel) {
  }),
  decompress: true // default 
  transitional: {
    silentJSONParsing: true; // default value for the current Axios version
    forcedJSONParsing: true;
    clarifyTimeoutError: false;
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;옵션&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;설명&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;기타&lt;/th&gt;
      &lt;th&gt; &lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;url&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;request를 요청할 서버 주소&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;method&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;request를 요청 방법&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;get, post, put …&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;baseURL&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;url이 절대적인 경우가 아니라면&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;https://some-domain.com/api/&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;transformRequest&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;서버에 request전에 data를 변환 PUT, POST, PATCH, DELETE 메소드의 경우 적용 가능&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;transformResponse&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;then/catch 전에 respponse 데이터를 변환한다&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;headers&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;XMLHttpRequest&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;params&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;request시 보낼 URL parameters, 반드시  plain object로 전송&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;params: {ID: 12345}&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;paramsSerializer&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;params을 serializing (직렬화) 하기 위한 옵션 함수&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;data&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;request body로서 전송하는 데이타&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;timeout&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;milliseconds 단위로 timeout 초과시 요청이 중단된다.&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;withCredentials&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;cross-site Access 허용할지 선택한다. 기본값 false&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;adapter&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;auth&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;Authorization 헤더를 세팅해야 함.&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;responseType&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;기본값 json&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;arraybuffer, document, json, text, stream&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;responseEncoding&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;response 인코딩 설정. 기본값 utf8&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;xsrfCookieName&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;xsrfHeaderName&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;onUploadProgress&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;업로드 프로그래스 이벤트를 핸들링합니다.&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;이해X&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;onDownloadProgress&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;다운로드 프로그래스 이벤트를 핸들링합니다.&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;이해X&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;maxContentLength&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;response content의 최대 byte 수를 정의함&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;maxBodyLength&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;response body의 최대 byte 수를 정의함&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;validateStatus&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;maxRedirects&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;node.js에서 최대 리다이렉트 개수를 설정함. 기본값 5&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;socketPath&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;node.js에서 UNIX 소켓을 정의함. 기본값 null&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;httpAgent&lt;br /&gt;httpsAgent&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;커스텀 agent를 정의한다&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;proxy&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;프록시 서버의 hostname, port, and protocol를 정의함&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;cancelToken&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;이전 request의 취소.. 이해 X&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;decompress&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;transitional&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&quot;액시오스-response&quot;&gt;액시오스 Response&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{
    data: {},
    status: 200,
    statusText: 'OK',
    headers: {},
    config: {},
    request: {}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;스키마&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;설명&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;기타&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;data&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;서버에서 제공하는 응답 데이터&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;{fe1: “Angular”, fe2: “React”, fe3: “Vue.js”}&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;status&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;HTTP status 코드&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;status: 200&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;statusText&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;HTTP status 메시지&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;statusText: ‘OK’&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;headers&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;서버에서 응답한 HTTP 헤더 정보&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;response.headers[‘content-type’]&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;config&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;axios request에 주어진 config정보&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;request&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;응답을 생성한 request (ClientRequest , XMLHttpRequest)&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;hr /&gt;
&lt;h2 id=&quot;reference&quot;&gt;reference&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://google.com&quot;&gt;구글&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.naver.com/&quot;&gt;네이버&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>zangzangs</name></author><summary type="html">액시오스(Axios) http 통신을 하기 위한 라이브러리로 Promise 기반의 API형식이 다양하게 제공된다. 따라서 별도의 로직을 구현할 필요 없이 주어진 API만으로도 간편하게 원하는 로직을 구현할 수 있습니다.</summary></entry><entry><title type="html">뷰 라우터</title><link href="http://localhost:4000/2021/04/30/vue-%EB%9D%BC%EC%9A%B0%ED%84%B0.html" rel="alternate" type="text/html" title="뷰 라우터" /><published>2021-04-30T20:11:00+09:00</published><updated>2021-04-30T20:11:00+09:00</updated><id>http://localhost:4000/2021/04/30/vue-%EB%9D%BC%EC%9A%B0%ED%84%B0</id><content type="html" xml:base="http://localhost:4000/2021/04/30/vue-%EB%9D%BC%EC%9A%B0%ED%84%B0.html">&lt;h2 id=&quot;라우팅이란&quot;&gt;🔹라우팅이란?&lt;/h2&gt;
&lt;p&gt;웹 페이지 간의 이동 방법을 말합니다. 라우팅은 현대 웹 앱 형태 중 하나인 실글 페이지 애플리케이션(SPA)에서 주로 사용하고 있습니다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;SPA, Single Page Application
단일 페이지로 구성된 웹 어플리케이션을 말한다. spa는 화면 이동 시에 필요한 데이터를 서버사이드에서 HTML로 전달 받지 않고(렌더링 X), 필요한 데이터만 서버로부터 필요한 데이터만 전달 받아 동적으로 렌더링한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;
&lt;h2 id=&quot;reference&quot;&gt;reference&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://google.com&quot;&gt;구글&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.naver.com/&quot;&gt;네이버&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>zangzangs</name></author><summary type="html">🔹라우팅이란? 웹 페이지 간의 이동 방법을 말합니다. 라우팅은 현대 웹 앱 형태 중 하나인 실글 페이지 애플리케이션(SPA)에서 주로 사용하고 있습니다.</summary></entry><entry><title type="html">뷰 컴포넌트 통신</title><link href="http://localhost:4000/2021/04/29/vue-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%ED%86%B5%EC%8B%A0.html" rel="alternate" type="text/html" title="뷰 컴포넌트 통신" /><published>2021-04-29T20:11:00+09:00</published><updated>2021-04-29T20:11:00+09:00</updated><id>http://localhost:4000/2021/04/29/vue-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%20%ED%86%B5%EC%8B%A0</id><content type="html" xml:base="http://localhost:4000/2021/04/29/vue-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%ED%86%B5%EC%8B%A0.html">&lt;p&gt;각각의 뷰 컴포넌트들은 독립적인 유효 범위(scope)를 갖기 때문에 직접적으로 컴포넌트의 data값을 참조할 수 없습니다.&lt;/p&gt;

&lt;h2 id=&quot;상위에서-하위-컴포넌트로-데이터-전달&quot;&gt;🔹상위에서 하위 컴포넌트로 데이터 전달&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;props 속성 사용&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;하위에서-상위-컴포넌트로-데이터-전달&quot;&gt;🔹하위에서 상위 컴포넌트로 데이터 전달&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;하위에서 발생한 이벤트를 통해 상위 컴포넌트로 데이터 전달&lt;/li&gt;
  &lt;li&gt;$emit() 과 v-on: 속성을 사용하여 구현한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;하위에서 상위 컴포넌트로 데이터를 넘기지 못하는 이유&lt;/strong&gt;
뷰의 데이터는 단방향으로 흐르도록 되어 있다.
공식 사이트에서 하위-&amp;gt;상위 컴포넌트로 데이터 전달을 다루고 있지 않다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;같은-레벨의-컴포넌트-간-통신&quot;&gt;같은 레벨의 컴포넌트 간 통신&lt;/h2&gt;

&lt;p&gt;🔹이벤트 버스&lt;/p&gt;

&lt;hr /&gt;
&lt;h2 id=&quot;reference&quot;&gt;reference&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://google.com&quot;&gt;구글&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.naver.com/&quot;&gt;네이버&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>zangzangs</name></author><summary type="html">각각의 뷰 컴포넌트들은 독립적인 유효 범위(scope)를 갖기 때문에 직접적으로 컴포넌트의 data값을 참조할 수 없습니다.</summary></entry><entry><title type="html">뷰 컴포넌트</title><link href="http://localhost:4000/2021/04/28/vue-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8.html" rel="alternate" type="text/html" title="뷰 컴포넌트" /><published>2021-04-28T20:11:00+09:00</published><updated>2021-04-28T20:11:00+09:00</updated><id>http://localhost:4000/2021/04/28/vue-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8</id><content type="html" xml:base="http://localhost:4000/2021/04/28/vue-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8.html">&lt;h2 id=&quot;전역-컴포넌트global-components&quot;&gt;🔹전역 컴포넌트(global components)&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Vue.component('컴포넌트 이름', {
    //컴포넌트 내용
    template: '&amp;lt;div&amp;gt;전역 컴포넌트가 등록되었습니다!&amp;lt;/div&amp;gt;'
});

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;지역-컴포넌트local-components&quot;&gt;🔹지역 컴포넌트(local components)&lt;/h2&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var cmp = {
    template: '&amp;lt;div&amp;gt;지역 컴포넌트 입니다.&amp;lt;/div&amp;gt;'
};

new Vue({
    el: '#app',
    components: {
        'my-local-component': cmp
    }
});

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;-vue-instance란&quot;&gt;▪ vue instance란?&lt;/h3&gt;

&lt;h3 id=&quot;-뷰-인스턴스-생성자&quot;&gt;▪ 뷰 인스턴스 생성자&lt;/h3&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;dom&quot;&gt;DOM&lt;/h2&gt;

&lt;h2 id=&quot;reference&quot;&gt;reference&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://google.com&quot;&gt;구글&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.naver.com/&quot;&gt;네이버&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>zangzangs</name></author><summary type="html">🔹전역 컴포넌트(global components)</summary></entry><entry><title type="html">뷰 인스턴스</title><link href="http://localhost:4000/2021/04/27/vue-%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4.html" rel="alternate" type="text/html" title="뷰 인스턴스" /><published>2021-04-27T20:11:00+09:00</published><updated>2021-04-27T20:11:00+09:00</updated><id>http://localhost:4000/2021/04/27/vue-%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4</id><content type="html" xml:base="http://localhost:4000/2021/04/27/vue-%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4.html">&lt;p&gt;안녕하세요?&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue@2.5.2/dist/vue.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;
    var tmp = new Vue({
    el: '#app',
    data: {
        message: 'Hello Vue.js!'
    },
    beforeCreate: function() {
        console.log(&quot;beforeCreate&quot;);
    },
    created: function() {
        console.log(&quot;created&quot;);
    },
    beforeMount: function(){
        console.log(&quot;beforeMount&quot;);
    },
    mounted: function() {
        console.log(&quot;mounted&quot;);
    },
    beforeUpdate: function(){
        console.log(&quot;beforeUpdate&quot;);
    },
    updated: function() {
        console.log(&quot;updated&quot;);
    },
    beforeDestroy:function(){
        console.log(&quot;beforeDestroy&quot;);
    },
    destroyed:function(){
        console.log(&quot;destroyed&quot;);
    }

    });
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;뷰-인스턴스&quot;&gt;🔹뷰 인스턴스&lt;/h2&gt;

&lt;h3 id=&quot;-vue-instance란&quot;&gt;▪ vue instance란?&lt;/h3&gt;

&lt;h3 id=&quot;-뷰-인스턴스-생성자&quot;&gt;▪ 뷰 인스턴스 생성자&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;new Vue({
    el: '#app',
    data: {
        message: 'Hello Vue.js!'
    }
})
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;dom&quot;&gt;DOM&lt;/h2&gt;

&lt;h3 id=&quot;-부제목-1&quot;&gt;▪ 부제목 1&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;el&lt;/li&gt;
  &lt;li&gt;templete&lt;/li&gt;
  &lt;li&gt;render&lt;/li&gt;
  &lt;li&gt;
    &lt;h2 id=&quot;rendererror&quot;&gt;renderError&lt;/h2&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;뷰-인스턴스-라이프-사이클-훅&quot;&gt;뷰 인스턴스 라이프 사이클 훅&lt;/h2&gt;

&lt;h3 id=&quot;-부제목-1-1&quot;&gt;▪ 부제목 1&lt;/h3&gt;

&lt;h3 id=&quot;-부제목-2&quot;&gt;▪ 부제목 2&lt;/h3&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;reference&quot;&gt;reference&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://google.com&quot;&gt;구글&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.naver.com/&quot;&gt;네이버&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>zangzangs</name></author><summary type="html">안녕하세요?</summary></entry><entry><title type="html">[운영체제] (5) CPU 스케줄링</title><link href="http://localhost:4000/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/2021/04/10/os05.html" rel="alternate" type="text/html" title="[운영체제] (5) CPU 스케줄링" /><published>2021-04-10T19:18:00+09:00</published><updated>2021-04-10T19:18:00+09:00</updated><id>http://localhost:4000/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/2021/04/10/os05</id><content type="html" xml:base="http://localhost:4000/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/2021/04/10/os05.html">&lt;p&gt;사용자 프로그램이 수행되는 과정은 &lt;strong&gt;CPU 작업과 I/O 작업의 반복&lt;/strong&gt;으로 수행된다.&lt;/p&gt;

&lt;p&gt;사용자 프로그램이 CPU를 직접 가지고 빠른 명령을 수행하는 일련의 단계를 &lt;strong&gt;CPU 버스트&lt;/strong&gt;라고 하고,
사용자 프로그램에 I/O 요청이 발생해 커널에 의해 입출력 작업을 진행하는 비교적 느린 &lt;strong&gt;I/O 버스트&lt;/strong&gt;라 한다.
사용자 프로그램은 사이클처럼 CPU 버스트와 I/O 버스트 작업이 번갈아 수행된다.&lt;/p&gt;

&lt;div style=&quot;text-align:center;&quot;&gt;
  &lt;img src=&quot;/assets/images/operating_system/chap06_burst.png&quot; style=&quot;zoom:110%&quot; /&gt;
&lt;/div&gt;

&lt;p&gt;모든 작업이 동일하다면 순서대로 처리하면 되겠지만, 실제 프로세스는 매우 다양한 작업이 섞여있다.
그렇다면 어떤 작업에 어떤 응답을 주어야 가장 효율이 높게 사용할 수 있을까?란 의문이 든다. 그래서 CPU 스케줄링이 필요하다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;CPU 스케줄링의 필요성
    &lt;ul&gt;
      &lt;li&gt;여러 종류의 job(=process)이 섞여 있기 때문에 스케줄링이 필요하다&lt;/li&gt;
      &lt;li&gt;interactive job에게 적절한 response 제공 요망&lt;/li&gt;
      &lt;li&gt;CPU와 I/O 장치 등 시스템 자원을 골고루 효율적으로 사용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;cpu-scheduler--dispatcher&quot;&gt;CPU Scheduler &amp;amp; Dispatcher&lt;/h2&gt;

&lt;h3 id=&quot;cpu-scheduler&quot;&gt;CPU Scheduler&lt;/h3&gt;
&lt;p&gt;준비 상태의 프로세스 중에서 이번에 CPU를 할당할 프로세스를 선택하는 코드&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;CPU 스케줄링이 필요한 상태 변화가 있는 경우 4가지
    &lt;ol&gt;
      &lt;li&gt;Running -&amp;gt; Blocked (ex: I/O 요청하는 시스템 콜 )&lt;/li&gt;
      &lt;li&gt;Running -&amp;gt; Ready (ex: 할당시간만료로 timer interrupt )&lt;/li&gt;
      &lt;li&gt;Blocked -&amp;gt; Ready (ex: I/O 완료후 인터럽트 )&lt;/li&gt;
      &lt;li&gt;Terminate&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;1,4  nonpreemptive (= 강제로 빼앗지 않고 자진 반납)
  이 외에는 preemptive(= 강제로 빼앗음)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;dispatcher&quot;&gt;Dispatcher&lt;/h3&gt;
&lt;p&gt;스케줄러에 의해 선택된 프로세스에게 CPU를 넘겨주고 작업을 수행할 수 있도록 하는 코드&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;PCB에 현재 프로세스의 상태를 저장한다.&lt;/li&gt;
  &lt;li&gt;새로 선택된 프로세스의 context의 PCB로부터 복원하고 CPU를 넘긴다&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이처럼 디스패처가 하나의 프로세스를 정지 시키고 다른 프로세스에게 CPU를 전달하기 까지 걸리는 시간을 &lt;strong&gt;dispatch latency&lt;/strong&gt; 라 한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;스케줄링의-성능-평가scheduling-criteria&quot;&gt;스케줄링의 성능 평가(Scheduling Criteria)&lt;/h2&gt;
&lt;p&gt;Performance Index (= Performance Measure, 성능 척도)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;CPU utilization(이용률)
    &lt;ul&gt;
      &lt;li&gt;keep the CPU as busy as possible&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Throughput(처리량)
    &lt;ul&gt;
      &lt;li&gt;of processes that complete their execution per time unit&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Turnaround time (소요시간, 반환시간)
    &lt;ul&gt;
      &lt;li&gt;amount of time to execute a particular process&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Waiting time (대기 시간)
    &lt;ul&gt;
      &lt;li&gt;amount of time a process has been waiting in the ready queue&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Response tiem (응답 시간)
    &lt;ul&gt;
      &lt;li&gt;amount of time it takes from when a request was submitted until the first response is produced, not output (for time-sharing environment)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;cpu-스케줄링-알고리즘&quot;&gt;CPU 스케줄링 알고리즘&lt;/h2&gt;

&lt;h3 id=&quot;fcfs-first-come-first-served&quot;&gt;FCFS (First-Come First-Served)&lt;/h3&gt;

&lt;p&gt;프로세스가 준비 큐에 도착한 시간 순서대로 CPU를 할당하는 방식을 말한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;CPU를 먼저 요청한 프로세스에게 CPU를 할당&lt;/li&gt;
  &lt;li&gt;프로세스가 자발적으로 CPU를 반납할 때까지 CPU를 빼앗지 않음&lt;/li&gt;
  &lt;li&gt;콘보이 현상(convoy effect)이 발생
    &lt;ul&gt;
      &lt;li&gt;먼저 도착한 프로세스의 성격에 따라 평균시간이 크게 달라짐&lt;/li&gt;
      &lt;li&gt;긴 프로세스 짧은 프로세스가 순서대로 오면 뒤 쪽의 짧은 프로세스는 많은 시간 기다려야 함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;sjfshortest-job_first&quot;&gt;SJF(Shortest-Job_First)&lt;/h3&gt;
&lt;p&gt;CPU 버스트가 가장 짧은 프로세스에 CPU를 먼저 할당하는 방식을 말한다.
평균 시간을 가장 짧게 하는 최적 알고리즘으로 알려져 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;nonpreemptive
    &lt;ul&gt;
      &lt;li&gt;일단 CPU를 선점하면 종료까지 사용한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;preemptive
    &lt;ul&gt;
      &lt;li&gt;프로세스의 남은 사용 시간을 기준으로 처리한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;srtfshortest-remaining-time-first&quot;&gt;SRTF(Shortest-Remaining-Time-First)&lt;/h3&gt;

&lt;p&gt;SJF의 선점형(preemptive) 구현 방식을 말한다.&lt;/p&gt;

&lt;h3 id=&quot;priority-scheduling&quot;&gt;Priority Scheduling&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;우선순위가 가장 높은 프로세스에게 제일 먼저 CPU를 할당한다.&lt;/li&gt;
  &lt;li&gt;우선순위값이 작을수록 높은 우선 순위를 갖는다.&lt;/li&gt;
  &lt;li&gt;CPU버스트 시간을 우선순위값으로 정의하면 우선순위 스케줄링은 SFJ알고리즘과 동일한 의미를 갖게 된다.&lt;/li&gt;
  &lt;li&gt;우선순위가 높은 프로세스가 계속 도착하여 대기중인 프로세스가 계속 대기하는 기아 현상이 발생 할 수 있다. 대기중인 프로세스의 우선순위를 조금씩 높이는 aging 방법으로 해결 할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;round-robin라운드-로빈&quot;&gt;Round Robin(라운드 로빈)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;각 프로세스는 동일한 크기의 할당 시간을 가진다. (1~100ms)&lt;/li&gt;
  &lt;li&gt;할당 시간이 지나면 프로세스는 선점(preempted)당하고 ready queue의 제일 뒤에 가서 다시 줄을 선다&lt;/li&gt;
  &lt;li&gt;n 개의 프로세스가 ready queue에 있고 할당 시간이 q  time unit인 경우 각 프로세스는 최대 q time unit 단위로 CPU 시간의 1/n을 얻는다.
=&amp;gt; 어떤 프로세스도 (n-1)q time unit 이상 기다리지 않는다.&lt;/li&gt;
  &lt;li&gt;할당시간이 너무 길면 FCFS와 같은 결과가 나온다.&lt;/li&gt;
  &lt;li&gt;할당시간이 너무 짧으면 오버헤드가 커지는 문제가 발생한다.&lt;/li&gt;
  &lt;li&gt;라운드로빈 스케줄링은 여러종류의 이질적인 프로세스가 실행중일 때 효과적이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;multilevel-queue&quot;&gt;Multilevel Queue&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Ready queue 를 여러 개로 분할
    &lt;ul&gt;
      &lt;li&gt;foreground(interactive)&lt;/li&gt;
      &lt;li&gt;background(batch - no human interactive)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;multilevel-feedback-queue&quot;&gt;Multilevel Feedback Queue&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;프로세스가 다른 큐로 이동 가능&lt;/li&gt;
  &lt;li&gt;에이징을 이와 같은 방식으로 구현할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;multiple-processor-scheduling&quot;&gt;Multiple-Processor Scheduling&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;CPU가 여러 개인 경우 스케줄링은 더욱 복잡해짐&lt;/li&gt;
  &lt;li&gt;Homogeneous processor인 경우
    &lt;ul&gt;
      &lt;li&gt;Queue에 한줄로 세워서 각 프로세서가 알아서 꺼내가게 할 수 있다.&lt;/li&gt;
      &lt;li&gt;반드시 틍정 프로세서에서 수행되어야 하는 프로세스가 있는 경우에는 문제가 더 복잡해짐&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Load sharing
    &lt;ul&gt;
      &lt;li&gt;일부 프로세서에 job이 몰리지 않도록 부하를 적절히 공유하는 메커니즘 필요&lt;/li&gt;
      &lt;li&gt;별개의 큐를 두는 방법 vs 공동 큐를 사용하는 방법&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Symmetric Multiprocessing(SMP)
    &lt;ul&gt;
      &lt;li&gt;각 프로세서가 각자 알아서 스케줄링 결정&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Asymmetric multiprocessing
    &lt;ul&gt;
      &lt;li&gt;하나의 프로세서가 시스템 데이터의 접근과 공유를 책임지고 나머지 프로세서는 거기에 따름
        &lt;blockquote&gt;
          &lt;blockquote&gt;
            &lt;p&gt;대장 CPU가 스케줄링함&lt;/p&gt;
          &lt;/blockquote&gt;
        &lt;/blockquote&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;real-time-scheduling&quot;&gt;Real-TIme Scheduling&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Hard real-time systems
    &lt;ul&gt;
      &lt;li&gt;정해진 시간 안에 반드시 끝내도록 스케줄링해야 함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Soft real-time computing
    &lt;ul&gt;
      &lt;li&gt;일반 프로세스에 비해 높은 우선순위를 갖도록 해야함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;thread-scheduling&quot;&gt;Thread Scheduling&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Local Scheduling
    &lt;ul&gt;
      &lt;li&gt;사용자 수준의 Thread 라이브러리에 의해 어떤 Thread를 스케줄할지 결정&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Global Scheduling
    &lt;ul&gt;
      &lt;li&gt;일반 프로세스와 마찬가지로 커널의 단기 스케줄러가 어떤 thread를 스케줄할지 결정&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;알고리즘-평가방법&quot;&gt;알고리즘 평가방법&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Queueing models
    &lt;ul&gt;
      &lt;li&gt;확률 분포로 주어지는 arrival rate와 sevice rate 등을 통해 각종 performance index 값을 계산&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Implementation(구현) &amp;amp; Measurement (성능 측정)
    &lt;ul&gt;
      &lt;li&gt;실제 시스템에 알고리즘을 구현하여 실제 작업에 대해서 성능을 측정 비교&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Simulation(모의 실현)
    &lt;ul&gt;
      &lt;li&gt;알고리즘을 모의 프로그램으로 작성후 trace를 입력으로 하여 결과 비교&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>zangzangs</name></author><category term="운영체제" /><category term="os" /><summary type="html">사용자 프로그램이 수행되는 과정은 CPU 작업과 I/O 작업의 반복으로 수행된다.</summary></entry><entry><title type="html">[운영체제] (4) 프로세스 관리</title><link href="http://localhost:4000/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/2021/04/02/os04.html" rel="alternate" type="text/html" title="[운영체제] (4) 프로세스 관리" /><published>2021-04-02T19:18:00+09:00</published><updated>2021-04-02T19:18:00+09:00</updated><id>http://localhost:4000/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/2021/04/02/os04</id><content type="html" xml:base="http://localhost:4000/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/2021/04/02/os04.html">&lt;h2 id=&quot;프로세스의-개념&quot;&gt;&lt;strong&gt;프로세스의 개념&lt;/strong&gt;&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Process is &lt;strong&gt;&lt;span style=&quot;color:red;&quot;&gt;a Programin execution &lt;/span&gt;&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;&lt;span style=&quot;color:red&quot;&gt;실행중인 프로그램&lt;/span&gt;&lt;/strong&gt; 을 프로세스라 한다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;프로세스의 문맥(context)
    &lt;blockquote&gt;
      &lt;p&gt;프로세스가 현재 &lt;strong&gt;어떤 상태&lt;/strong&gt;에서 수행되고 있는지 정확히 규명하기 위해 필요한 정보를 말한다.&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;프로세스 문맥은 크게 3가지로 &lt;strong&gt;하드웨어 문맥&lt;/strong&gt;, &lt;strong&gt;프로세스의 주소공간&lt;/strong&gt;, &lt;strong&gt;커널상의 문맥&lt;/strong&gt;으로 나누어 볼 수 있다.&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;CPU 수행 상태를 나타내는 &lt;strong&gt;하드웨어 문맥&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;Program Counter&lt;/li&gt;
          &lt;li&gt;각종 register&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;프로세스의 주소 공간&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;code, data, stack&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;프로세스 관련 &lt;strong&gt;커널&lt;/strong&gt; 자료 구조
        &lt;ul&gt;
          &lt;li&gt;PCB (Process Control Block)&lt;/li&gt;
          &lt;li&gt;Kernel stack (커널내의 주소)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2&gt;&lt;br /&gt;&lt;/h2&gt;

&lt;h2 id=&quot;프로세스의-상태&quot;&gt;&lt;strong&gt;프로세스의 상태&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;프로세스의 상태는 실행(running), 준비(ready), 봉쇄(blocked, wait, sleep)의 세 가지로 구분할 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;실행(Running)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;프로세스가 CPU를 잡고 기계어 instruction을 수행중인 상태를 말한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;준비(Ready)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;CPU만 보유하면 당장 명령을 수행 할 수 있도록 CPU를 기다리는 상태(메모리 등 다른 조건을 모두 만족)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;봉쇄(blocked, wait, sleep)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;CPU를 할당받더라도 당장 명령을 실행할 수 없는 상태를 말한다.
        &lt;ul&gt;
          &lt;li&gt;I/O 등의 event를 (스스로) 기다리는 상태&lt;/li&gt;
          &lt;li&gt;디스크에서 file을 읽어와야 하는 경우&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;시작 상태
    &lt;ul&gt;
      &lt;li&gt;프로세스가 시작되어 그 프로세스를 위한 각종 자료구조는 생성되었지만 아직 메모리 획득을 승인받지 못한 상태&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;완료 상태
    &lt;ul&gt;
      &lt;li&gt;프로세스가 종료되었으나 운영체제가 그 프로세스와 관련된 자료구조를 완전히 정리하지 못한 상태&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;​ &lt;strong&gt;Suspended (stoped)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;외부적인 이유로 프로세스의 수행이 정지된 상태&lt;/li&gt;
      &lt;li&gt;프로세스는 통째로 디스크에 swap out 된다&lt;/li&gt;
      &lt;li&gt;ex) 사용자 프로그램을 일시 정지시킨 경우 (break key) 시스템이 여러 이유로 프로세스를 잠시 중단시킴(메모리에 너무 많은 프로세스가 올라와 있을 때)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;ul&gt;
    &lt;li&gt;Blocked: 자신이 요청한 event가 만족되면 Ready&lt;/li&gt;
    &lt;li&gt;Suspended: 외부에서 resume해 주어야 Active&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;div style=&quot;text-align:center;&quot;&gt;
  &lt;img src=&quot;/assets/images/operating_system/chap05_프로세스의_상태_변화도.png&quot; style=&quot;zoom:70%&quot; /&gt;
  프로세스의 상태 변화도
&lt;/div&gt;

&lt;h2 id=&quot;-1&quot;&gt;&lt;br /&gt;&lt;/h2&gt;

&lt;h2 id=&quot;process-control-block-pcb&quot;&gt;Process Control Block (PCB)&lt;/h2&gt;
&lt;p&gt;프로세스 제어블록이란 운영체제가 시스템 내의 프로세스들을 관리하기 위해 프로세스마다 유지하는 정보들을 담는 커널 내의 자료구조를 말한다.&lt;/p&gt;

&lt;div style=&quot;text-align:center;&quot;&gt;
  &lt;img src=&quot;/assets/images/operating_system/ch05_PCB구성.png&quot; style=&quot;zoom:50%&quot; /&gt;
  프로세스 제어블록(PCB)의 구성
&lt;/div&gt;

&lt;!-- 
- 다음의 구성요소를 가진다 (구조체로 유지)
  1. OS 관리상 사용하는 정보  
     - 프로세스 상태(Process state), Process ID  
     - 스케쥴링 정보(scheduling information), 우선순위(priority)  
  2. CPU 수행 관련 하드웨어 값  
     - Program counter  
     - registers(현 시점에 레지스터에 어떤 값을 저장하고 있는지)  
  3. 메모리 관련  
     - code, data, stack 의 위치정보  
  4. 파일 관련  
     - Open file descriptors
--&gt;

&lt;h2 id=&quot;-2&quot;&gt;&lt;br /&gt;&lt;/h2&gt;

&lt;h2 id=&quot;문맥-교환-context-switch&quot;&gt;&lt;strong&gt;문맥 교환 (Context Switch)&lt;/strong&gt;&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;한 프로세스에서 다른 프로세스로 CPU의 제어권을 넘겨주는 과정&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;CPU가 다른 프로세스에게 넘어갈 때 운영체제는 다음을 수행한다.
    &lt;ol&gt;
      &lt;li&gt;CPU를 내어주는 프로세스의 문맥(context)를 그 프로세스의 PCB에 저장&lt;/li&gt;
      &lt;li&gt;CPU를 새롭게 얻는 프로세스의 문맥(context)을 PCB로부터 읽어 실제 하드웨어로 복원&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;문맥교환이 아닌 것과 혼동하지 말자. 문맥교환은 프로세스A에서 프로세스B로 넘어가는것&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;System call이나 interrupt 발생시 반드시 context switch가 일어나는 것은 아니다
    &lt;ol&gt;
      &lt;li&gt;&lt;strong&gt;문맥교환 &lt;span style=&quot;color:red&quot;&gt;X&lt;/span&gt;&lt;/strong&gt;
 사용자 프로세스 A -&amp;gt; interrupt or system call -&amp;gt; 커널모드) -&amp;gt; &lt;strong&gt;&lt;span style=&quot;color:red&quot;&gt;문맥 교환 없이 user 모드 복귀&lt;/span&gt;&lt;/strong&gt; -&amp;gt; 사용자 프로세스 A&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;문맥교환 &lt;span style=&quot;color:blue&quot;&gt;O&lt;/span&gt;&lt;/strong&gt;
 사용자 프로세스 A -&amp;gt; interrupt or I/O 요청 system call  -&amp;gt; 커널모드(ISR or system call) -&amp;gt; &lt;strong&gt;&lt;span style=&quot;color:blue&quot;&gt;문맥 교환 발생&lt;/span&gt;&lt;/strong&gt; -&amp;gt; 사용자 프로세스 B&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;(1)의 경우에도 CPU 수행 정보 등 context의 일부를 PCB에 save해야 하지만 문맥교환을 하는 (2)의 경우 그 부담이 훨씬 크다. (eg. cache memory flush)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;-3&quot;&gt;&lt;br /&gt;&lt;/h2&gt;

&lt;h2 id=&quot;프로세스를-스케줄링하기-위한-큐&quot;&gt;&lt;strong&gt;프로세스를 스케줄링하기 위한 큐&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;운영체제는 하드웨어와 소프트웨어 자원을 줄세우기 위해 여러 Queue를 두어 사용한다. 프로세스들은 각 Queue들을 오가며 수행된다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Job queue&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;현재 시스템 내에 있는 모든 프로세스의 집합&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Ready queue&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;현재 메모리 내에 있으면서 CPU를 잡아서 실행되기를 기다리는 프로세스의 집합&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Device queues&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;I/O device의 처리를 기다리는 프로세스의 집합&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-4&quot;&gt;&lt;br /&gt;&lt;/h2&gt;

&lt;h2 id=&quot;스케줄러-scheduler&quot;&gt;&lt;strong&gt;스케줄러 (Scheduler)&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;스케줄러란 어떤 프로세스에게 자원을 할당할지를 결정하는 운영체제 커널의 코드를 지칭한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;long-term-scheduler장기-스케줄러-or-job-scheduler&quot;&gt;&lt;strong&gt;Long-term scheduler(장기 스케줄러 or job scheduler)&lt;/strong&gt;&lt;/h4&gt;
    &lt;ul&gt;
      &lt;li&gt;시작 프로세스 중 어떤 것들을 &lt;strong&gt;ready queue&lt;/strong&gt;로 보낼지 결정&lt;/li&gt;
      &lt;li&gt;프로세스에 memory(및 각종 자원)을 주는 문제&lt;/li&gt;
      &lt;li&gt;degree of Multiprogramming을 제어&lt;/li&gt;
      &lt;li&gt;time sharing system에는 보통 장기 스케줄러가 없음(무조건 ready)&lt;/li&gt;
    &lt;/ul&gt;

    &lt;blockquote&gt;
      &lt;ul&gt;
        &lt;li&gt;프로세스 상태도에서 admitted 해주는게 장기스케줄러의 역할&lt;/li&gt;
        &lt;li&gt;&lt;em&gt;현대의 운영체제(시분할 시스템)는 하드웨어의 발전으로 장기 스케줄러 사용하지 않음&lt;/em&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;short-term-scheduler단기-스케줄러-or-cpu-scheduler&quot;&gt;&lt;strong&gt;Short-term scheduler(단기 스케줄러 or CPU scheduler)&lt;/strong&gt;&lt;/h4&gt;
    &lt;ul&gt;
      &lt;li&gt;ready queue에 있는 프로세스들 중 다음번에 running 시킬 프로세스를 결정&lt;/li&gt;
      &lt;li&gt;프로세스에 CPU를 할당하는 역할&lt;/li&gt;
      &lt;li&gt;매우 빈번하게 호출되므로 빨라야 한다 (millisecond 단위)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;medium-term-scheduler중기-스케줄러-or-swapper&quot;&gt;&lt;strong&gt;Medium-Term Scheduler(중기 스케줄러 or Swapper)&lt;/strong&gt;&lt;/h4&gt;
    &lt;blockquote&gt;
      &lt;p&gt;현대의 운영체제(시분할 시스템)에서 장기 스케줄러 사용이 낮아지면서 중기 스케줄러를 사용&lt;/p&gt;
    &lt;/blockquote&gt;
    &lt;ul&gt;
      &lt;li&gt;많은 프로세스에게 메모리를 할당해 시스템의 성능이 저하되는 일을 조절한다
        &lt;ul&gt;
          &lt;li&gt;프로세스에게서 메모리를 빼앗음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;여유 공간 마련을 위해 프로세스를 통째로 메모리에서 디스크의 swap 영역으로 저장함 &lt;strong&gt;(swap out)&lt;/strong&gt;
        &lt;ul&gt;
          &lt;li&gt;봉쇄(block) 상태에 있는 프로세스가 0순위로 swap out&lt;/li&gt;
          &lt;li&gt;그래도 부족하면 타이머 인터럽트로 ready queue로 이동하는 프로세스를 추가적으로 swap out&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;degree of Multiprogramming을 제어&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div style=&quot;text-align:center;&quot;&gt;
  &lt;img src=&quot;/assets/images/operating_system/chap05_프로세스_상태_변화도_중지_상태_포함.png&quot; style=&quot;zoom:90%&quot; /&gt;
  중지 상태를 포함한 프로세스의 상태 변화도
&lt;/div&gt;

&lt;h2 id=&quot;-5&quot;&gt;&lt;br /&gt;&lt;/h2&gt;

&lt;!-- ## Thread (쓰레드)

&gt; **A &lt;span style=&quot;color:red&quot;&gt;thread&lt;/span&gt; (or &lt;span style=&quot;color:red&quot;&gt;lightweight process&lt;/span&gt;) is a basic unit of CPU utilization**

- Thread의 구성
  - program counter
  - register set
  - stack space
- Thread가 동료 Thread와 공유하는 부분(=task)
  - code section
  - data section
  - OS resources
- 전통적인 개념의 heavyweight process는 하나의 thread를 가지고 있는 task로 볼 수 있다
- 다중 스레드로 구성된 테스크 구조에서는 하나의 서버 스레드가 blocked (waiting) 상태인 동안에도 동일한 태스크 내의 다른 스레드가 실행(running)되어 빠른 처리를 할 수 있다.
- 동일한 일을 수행하는 다중 스레드가 협력하여 높은 처리율(throughput)과 성능 향상을 얻을 수 있다
- 스레드를 사용하면 병렬성을 높일 수 있다



### Benefits of Threads

- Responsiveness
  - 동시 처리로 빠른 응답성을 제공한다.
- Resource Sharing
  -  프로세스의 리소스인 code, data를 n개의 쓰레드가 공유할 수 있다.(stack 제외)
- Economy
  - creating &amp; CPU switching thread (rather than a process)
  - Solaris의 경우 위 두 가지 overhead가 각각 30배, 5배
- Utilization of MP Architectures
  - 멀티 프로세서 아키텍처의 사용에서 각각의 쓰레드를 다른 프로세서에서 병렬로 실행한다.

&lt;br&gt;

### Implementation of Threads

- Kernel Threads 

  &gt; Some are supported by kernel  
  &gt;
  &gt; 운영체제 커널이 지원하는 Threads 

  - Windows
  - Solaris
  - Digital UNIX, Mach

- User Threads

  &gt; Others are Supported by library
  &gt;
  &gt; 사용자가 에서 Threads를 관리

  - POSIX Pthreads
  - Mach C-threads
  - Solaris threds

- Some are real-time threads 

&lt;br&gt;
--- ,,
--&gt;

&lt;h2 id=&quot;프로세스-생성&quot;&gt;&lt;strong&gt;프로세스 생성&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;시스템이 부팅된 후 최초의 프로세스는 운영체제가 직접 생성하지만 그다음부터는 이미 존재하는 프로세스가 다른 프로세스를 복제 생성하게 된다. 이때 프로세스를 생성한 프로세스를  &lt;strong&gt;&lt;span style=&quot;color:blue&quot;&gt;부모 프로세스(parent process)&lt;/span&gt;&lt;/strong&gt; 라고 하고 새롭게 생성된 프로세스를  &lt;strong&gt;&lt;span style=&quot;color:blue&quot;&gt; 자식 프로세스(children process)&lt;/span&gt;&lt;/strong&gt; 라고 한다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;부모 프로세스(parent process)&lt;/strong&gt; 가 &lt;strong&gt;자식 프로세스(children process)&lt;/strong&gt; 생성&lt;/li&gt;
  &lt;li&gt;프로세스의 트리(계층 구조) 형성&lt;/li&gt;
  &lt;li&gt;프로세스는 자원을 필요로함
    &lt;ul&gt;
      &lt;li&gt;운영체제로부터 받는다&lt;/li&gt;
      &lt;li&gt;부모와 공유한다
        &lt;ul&gt;
          &lt;li&gt;자원의 공유
            &lt;ul&gt;
              &lt;li&gt;부모와 자식이 모든 자원을 공유하는 모델&lt;/li&gt;
              &lt;li&gt;일부를 공유하는 모델&lt;/li&gt;
              &lt;li&gt;전혀 공유하지 않는 모델&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;수행 (Execution)
    &lt;ul&gt;
      &lt;li&gt;부모와 자식은 공존하며 수행되는 모델&lt;/li&gt;
      &lt;li&gt;자식이 종료(terminate)될 때까지 부모가 기다리는(wait) 모델&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;주소 공간 (Address space)
    &lt;ul&gt;
      &lt;li&gt;자식은 부모의 공간을 복사함 (binary and OS data)&lt;/li&gt;
      &lt;li&gt;자식은 부모의 공간을 복사함 (binary and OS data)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;유닉스의 예
    &lt;ul&gt;
      &lt;li&gt;&lt;span style=&quot;color:red&quot;&gt;fork()&lt;/span&gt; 시스템 콜이 새로운 프로세스를 생성
        &lt;ul&gt;
          &lt;li&gt;부모를 그대로 복사 (OS data except PID + binary)&lt;/li&gt;
          &lt;li&gt;주소 공간 할당&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;fork 다음에 이어지는 &lt;span style=&quot;color:red&quot;&gt;exec()&lt;/span&gt; 시스템 콜을 통해 새로운 프로그램을 메모리에 올림&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;프로세스가 마지막 명령을 수행한 후 운영체제에게 이를 알려줌(&lt;span style=&quot;color:red&quot;&gt;exit&lt;/span&gt;)
    &lt;ul&gt;
      &lt;li&gt;자식이 부모에게 output data를 보냄 (via &lt;span style=&quot;color:red&quot;&gt;wait&lt;/span&gt;)&lt;/li&gt;
      &lt;li&gt;프로세스의 각종 자원들이 운영체제에게 반납됨&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;부모 프로세스가 자식의 수행을 종료시킴 (&lt;span style=&quot;color:red&quot;&gt;abort&lt;/span&gt;)
    &lt;ul&gt;
      &lt;li&gt;자식이 할당 자원의 한계치를 넘어섬&lt;/li&gt;
      &lt;li&gt;자식에게 할당된 태스크가 더 이상 필요하지 않음&lt;/li&gt;
      &lt;li&gt;부모가 종료(exit)하는 경우
        &lt;ul&gt;
          &lt;li&gt;운영체제는 부모 프로세스가 종료하는 경우 자식 프로세스가 더 이상 수행되도록 두지 않는다(종료해버림)&lt;/li&gt;
          &lt;li&gt;프로세스의 계층 구조(트리)에 따라 단계적인 종료가 됨&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;프로세스-생성-절차&quot;&gt;프로세스 생성 절차&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Fork() 시스템 콜&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;프로세스 ID를 제외한 모든 내용을 그대로 복제 생성한다.&lt;/li&gt;
      &lt;li&gt;부모와 자식 프로세스는 서로 다른 주소공간을 갖는다.(주소공간 내용은 동일)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;exec() 시스템 콜&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;하나의 프로세스를 완전히 새로운 프로세스로 덮어쓰는 명령&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;wait() 시스템 콜&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;자식 프로세스가 종료되기를 기다리며 부모 프로세스가 봉쇄 상태에 머무르도록 할 때 사용된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;exit() 시스템 콜&lt;/strong&gt;
프로세스의 종료 종료하는 명령이다. 종료 명령은 자발적 종료와 비자발적 종료로 구분 된다.
    &lt;ul&gt;
      &lt;li&gt;자발적 종료
        &lt;ul&gt;
          &lt;li&gt;마지막 statement 수행 후 exit() 시스템 콜&lt;/li&gt;
          &lt;li&gt;프로그램에 명시적으로 적어주지 않아도 main함수가 리턴되는 위치에 컴파일러가 넣어줌&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;비자발적 종료
        &lt;ol&gt;
          &lt;li&gt;자식 프로세스가 한계치를 넘어서는 자원 요청하는 경우&lt;/li&gt;
          &lt;li&gt;자식에게 할당된 작업이 더 이상 필요하지 않는 경우&lt;/li&gt;
          &lt;li&gt;부모 프로세스가 종료되는 경우&lt;/li&gt;
          &lt;li&gt;키보드로 kill, break 등을 친 경우&lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;-6&quot;&gt;&lt;br /&gt;&lt;/h2&gt;

&lt;h2 id=&quot;프로세스-간-협력&quot;&gt;&lt;strong&gt;프로세스 간 협력&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;원칙적으로 프로세스는 각자 자신만의 독립적인 주소 공간을 가지기 때문에 &lt;em&gt;다른 프로세스의 주소 공간을 참조하는 것은 허용되지 않는다.&lt;/em&gt; 그러나 경우에 따라서 &lt;em&gt;프로세스들 간의 협력이 효율을 증가시키는 점에서 더 생산적일 수 있다.&lt;/em&gt; 따라서 &lt;strong&gt;운영체제는 프로세스들간의 협력을 위한 매커니즘을 제공&lt;/strong&gt;한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;독립적 프로세스(Independent process)&lt;/strong&gt;
프로세스는 각자의 주소 공간을 가지고 수행되므로 원칙적으로 하나의 프로세스는 다른 프로세스의 수행에 영향을 미치지 못함&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;협력 프로세스(Cooperating process)&lt;/strong&gt;
프로세스 협력 메커니즘을 통해 하나의 프로세스가 다른 프로세스의 수행에 영향을 미칠 수 있음&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;프로세스-간-협력-메커니즘-ipc-interprocess-communication&quot;&gt;프로세스 간 협력 메커니즘 (IPC: Interprocess Communication)&lt;/h3&gt;

&lt;p&gt;IPC란 하나의 컴퓨터 안에서 실행 중인 서로 다른 프로세스 간에 발생하는 통신과 동기화를 이루기 위한 매커니즘을 말한다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;메시지를 전달하는 방법(Message passing)&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;프로세스 사이에 공유 변수(shared variable)를 일체 사용하지 않고 통신하는 시스템&lt;/li&gt;
      &lt;li&gt;커널을 통해 메시지를 주고 받음&lt;/li&gt;
      &lt;li&gt;커뮤니케이션 링크를 생성하고 send(), receive()&lt;/li&gt;
      &lt;li&gt;커뮤니케이션 링크 방법
        &lt;ol&gt;
          &lt;li&gt;Direct Communication
            &lt;ul&gt;
              &lt;li&gt;통신하려는 프로세스의 이름을 명시적으로 표시&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
          &lt;li&gt;Indirect Communication
            &lt;ul&gt;
              &lt;li&gt;mailbox (또는 port)를 통해 메시지를 간접 전달
&lt;br /&gt;&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;주소 공간을 공유하는 방법(Shared memory)&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;서로 다른 프로세스 간에 일부 주소 공간을 공유하게 하는 공유 메모리 매커니즘&lt;/li&gt;
      &lt;li&gt;같은 메모리 공간 사용으로 일관성 문제가 유발될 수 있음&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;Thread는 사실상 하나의 프로세스이므로 프로세스 간 협력으로 보기는 어렵지만 동일한 프로세스를 구성하는 Threads들 간에는 주소 공간을 공유하므로 협력이 가능&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div style=&quot;text-align:center;&quot;&gt;
  &lt;img src=&quot;/assets/images/operating_system/chap05_ipc.png&quot; style=&quot;zoom:60%&quot; /&gt;
  hared memory VS Message passing
&lt;div&gt;

&lt;/div&gt;&lt;/div&gt;</content><author><name>zangzangs</name></author><category term="운영체제" /><category term="os" /><summary type="html">프로세스의 개념</summary></entry><entry><title type="html">[운영체제] (3) 프로그램의 구조와 실행</title><link href="http://localhost:4000/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/2021/03/28/os03.html" rel="alternate" type="text/html" title="[운영체제] (3) 프로그램의 구조와 실행" /><published>2021-03-28T19:18:00+09:00</published><updated>2021-03-28T19:18:00+09:00</updated><id>http://localhost:4000/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/2021/03/28/os03</id><content type="html" xml:base="http://localhost:4000/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/2021/03/28/os03.html">&lt;h2 id=&quot;프로그램의-실행&quot;&gt;프로그램의 실행&lt;/h2&gt;

&lt;p&gt;프로그램의 실행은 두가지 중요한 의미를 가진다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;파일 시스템에 존재하던 실행파일이 메모리에 적재된다는 의미&lt;/li&gt;
  &lt;li&gt;프로그램이 CPU를 할당받고 명령을 수행하고 있는 상태&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;파일 시스템에 있는 실행 파일이 메모리에 적재될 때, 실행파일 전체가 메모리에 올라가지 않는다. 일부분만 메모리에 올라가고 나머지는 디스크의 특정영역인 스왑 영역에 존재한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;가상-메모리-virtual-memory&quot;&gt;가상 메모리 (virtual memory)&lt;/h2&gt;

&lt;p&gt;프로세스의 주소 공간은 코드(code), 데이타(data), 스택(stack)영역으로 구성된다. 이러한 주소 공간을 우리는 가상 메모리 (또는 논리적 메모리: logical memory)라고 부른다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;code&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;사용자가 작성한 프로그램 함수들의 코드가 CPU에서 수행할 수 있는 기계어 명령 형태로 변환되어 저장되는 공간&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;data&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;전역 변수 등 프로그램이 사용하는 데이터를 저장하는 공간&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;stack&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;호출된 함수의 수행을 마치고 복귀할 주소 및 데이터를 임시로 저장하는 공간&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;커널-주소-공간의-내용&quot;&gt;커널 주소 공간의 내용&lt;/h2&gt;

&lt;p&gt;운영체제도 하나의 프로세스이기 때문에 커널 역시 동일한 주소 공간인 code, data, stack 영역을 갖는다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;code&quot;&gt;code&lt;/h4&gt;
    &lt;ul&gt;
      &lt;li&gt;시스템 콜, 인터럽트 처리 코드&lt;/li&gt;
      &lt;li&gt;CPU, 메모리 등 자원 관리를 위한 코드&lt;/li&gt;
      &lt;li&gt;편리한 인터페이스 제공을 위한 코드&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;data&quot;&gt;data&lt;/h4&gt;
    &lt;ul&gt;
      &lt;li&gt;PCB(Process Controll Block)
        &lt;ul&gt;
          &lt;li&gt;현재 수행 중인 프로세스의 상태, CPU 사용 정보 등을 유지하기 위한 자료구조&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;CPU, Memory 등 하드웨어 자원을 관리하기 위한 자료구조가 저장&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;h4 id=&quot;stack&quot;&gt;stack&lt;/h4&gt;
    &lt;ul&gt;
      &lt;li&gt;각 Process의 커널 스택을 저장
        &lt;ul&gt;
          &lt;li&gt;프로세스는 함수 호출시 자신의 복귀 주소를 저장하지만, 커널은 커널 내의 주소가 된다.&lt;/li&gt;
          &lt;li&gt;각각의 프로세스마다 별도의 스택을 두어 관리한다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;사용자-프로그램이-사용하는-함수&quot;&gt;사용자 프로그램이 사용하는 함수&lt;/h2&gt;
&lt;p&gt;함수는 크게 두가지로 나눌 수 있다. 프로세스 함수와 커널함수&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;사용자 정의 함수(프로세스 함수)
    &lt;ul&gt;
      &lt;li&gt;자신의 프로그램에서 정의한 함수&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;라이브러리 함수(프로세스 함수)
    &lt;ul&gt;
      &lt;li&gt;자신의 프로그램에서 정의하지 않고 갖다 쓴 함수&lt;/li&gt;
      &lt;li&gt;자신의 프로그램의 실행 파일에 포함되어 있다.&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;커널 함수
    &lt;ul&gt;
      &lt;li&gt;운영체제 프로그램의 함수&lt;/li&gt;
      &lt;li&gt;커널 함수의 호출 = 시스템 콜&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;인터럽트&quot;&gt;인터럽트&lt;/h2&gt;

&lt;p&gt;CPU는 매번 프로그램 카운터가 가리키고 있는 지점의 명령을 하나씩 수행하고 나서, 다음 명령을 수행하기 직전에 인터럽트 라인이 세팅되었는지 체크한다. 인터럽트 라인 체크를 통해 인터럽트가 발생했으면 CPU는 현재 수행하던 프로세스를 멈추고 운영체제의 인터럽트 처리 루틴으로 이동해서 인터럽트 처리를 수행한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;그렇다면 인터럽트 처리중에 또다른 인터럽트가 발생하는 경우는 어떻게 되는가?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;원직적으로는 인터럽트 처리중에 또 다른 인터럽트의 처리를 허용하지 않는다.
    &lt;ul&gt;
      &lt;li&gt;앞서 변경중이던 데이터를 또다른 인터럽트가 발생해 처리하게 되면 의도하지 않은 결과값으로 바뀔 수 있기 때문이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;예외적인 경우가 존재한다.
    &lt;ul&gt;
      &lt;li&gt;인터럽트마다 중요도가 다르다.&lt;/li&gt;
      &lt;li&gt;상대적으로 낮은 중요도를 가진 인터럽트를 처리하는 도중 높은 중요도의 인터럽트 발생을 허용한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;프로세스의-두-가지-실행-상태&quot;&gt;프로세스의 두 가지 실행 상태&lt;/h2&gt;
&lt;p&gt;mode bit에 따라 user mode, kernel mode를 반복하며 실행된다. 프로그램이 시작되어 종료될 때까지 다양한 함수 호출을 하며 실행되는데, 이를 사용자 모드와 커널모드의 실행 상태로 구분 지을 수 있다&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;사용자 모드(user mode)
    &lt;ul&gt;
      &lt;li&gt;프로그램이 사용자 정의함수나 라이브러리 함수를 호출&lt;/li&gt;
      &lt;li&gt;시스템 콜의 실행이 끝나고 시스템 콜 이후의 명령을 수행하는 경우&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;커널 모드(kernel mode)
    &lt;ul&gt;
      &lt;li&gt;시스템 콜을 하는 경우&lt;/li&gt;
      &lt;li&gt;프로그램의 실행이 끝날 때 커널모드로 진입하여 프로그램을 종료함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;</content><author><name>zangzangs</name></author><category term="운영체제" /><category term="os" /><summary type="html">프로그램의 실행</summary></entry><entry><title type="html">[운영체제] (2) 컴퓨터 시스템의 동작 원리</title><link href="http://localhost:4000/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/2021/03/21/os02.html" rel="alternate" type="text/html" title="[운영체제] (2) 컴퓨터 시스템의 동작 원리" /><published>2021-03-21T19:18:00+09:00</published><updated>2021-03-21T19:18:00+09:00</updated><id>http://localhost:4000/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/2021/03/21/os02</id><content type="html" xml:base="http://localhost:4000/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C/2021/03/21/os02.html">&lt;h2 id=&quot;컴퓨터-시스템-구조&quot;&gt;컴퓨터 시스템 구조&lt;/h2&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;div style=&quot;text-align:center;&quot;&gt;
  &lt;img src=&quot;/assets/images/operating_system/chap03_computer_system_structure.png&quot; style=&quot;zoom:60%&quot; /&gt;
  &lt;span style=&quot;color:gray; size:10&quot;&gt;컴퓨터 시스템 구조&lt;/span&gt;
&lt;/div&gt;

&lt;h3 id=&quot;1-cpu&quot;&gt;1. CPU&lt;/h3&gt;
&lt;p&gt;중앙처리장치라 불리는 CPU는 인간의 &lt;strong&gt;두뇌&lt;/strong&gt;와 같은 역할을 합니다. &lt;strong&gt;중앙처리장치(central processing unit)&lt;/strong&gt; 라는 말 그대로 중앙에서 사용자가 입력한 명령어를 해석하고 연산한 후 그 결과를&lt;/p&gt;

&lt;h3 id=&quot;2-메모리&quot;&gt;2. 메모리&lt;/h3&gt;
&lt;p&gt;랜덤 액세스 메모리(Random Access Memory) 즉, 램(RAM)은 임의의 영역에 접근하여 읽고 쓰기가 가능한 주기억 장치다. RAM은 어느 위치에 저장된 데이터든지 접근(읽기 및 쓰기)하는 데 동일한 시간이 걸리는 메모리이기에 ‘랜덤(Random, 무작위)’이라는 명칭이 주어진다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;3-device-controller&quot;&gt;3. Device Controller&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;I/O device controller
    &lt;ul&gt;
      &lt;li&gt;해당 I/O 장치 유형을 관리하는 일종의 작은 CPU&lt;/li&gt;
      &lt;li&gt;제어 정보를 위해 control register, status register가 있다.&lt;/li&gt;
      &lt;li&gt;local buffer를 갖는다 (=일종의 data register)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;I/O는 실제 device와 local buffer 사이에서 일어남&lt;/li&gt;
  &lt;li&gt;Device controller는 I/O가 끝났을 경우 interrupt로 CPU에 그 사실을 알림&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;dl&gt;
    &lt;dt&gt;device driver(장치구동기)&lt;/dt&gt;
    &lt;dd&gt;os 코드 중 각 장치별 처리루틴 -&amp;gt; software&lt;br /&gt;
device controller(장치제어기)&lt;/dd&gt;
    &lt;dd&gt;각 장치를 통제하는 일종의 작은 cpu -&amp;gt; hardware&lt;/dd&gt;
  &lt;/dl&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;4-interrupt-line&quot;&gt;4. Interrupt line&lt;/h3&gt;
&lt;p&gt;CPU로 인터럽트 신호를 보낼 수 있는 하드웨어 라인&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;5-mode-bit&quot;&gt;5. Mode bit&lt;/h3&gt;
&lt;p&gt;사용자 프로그램의 잘못된 수행으로 다른 프로그램 및 운영체제에 피해가 가지 않도록 하기 위한 보호장치가 필요
Mode bit을 통해 하드웨어적으로 두 가지 모드의 operation 지원&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;1 &lt;span style=&quot;color:blue&quot;&gt;사용자 모드&lt;/span&gt; : 사용자 프로그램 수행&lt;br /&gt;
0 &lt;span style=&quot;color:red&quot;&gt;모니터 모드&lt;/span&gt; : OS 코드 수행 (=커널 모드, 시스템 모드)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;보안을 해칠 수 있는 중요한 명령어는 모니터 모드에서만 수행 가능한 &lt;strong&gt;‘특권명령’&lt;/strong&gt; 으로 규정&lt;/li&gt;
  &lt;li&gt;Interrupt나 Exception 발생시 하드웨어가 mode bit을 0으로 변경&lt;/li&gt;
  &lt;li&gt;사용자 프로그램에게 CPU를 넘기기 전에 mode bit을 1로 변경&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;6-timer&quot;&gt;6. Timer&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;타이머
    &lt;ul&gt;
      &lt;li&gt;정해진 시간이 흐른 뒤 운영체제에게 제어권이 넘어가도록 인터럽트를 발생&lt;/li&gt;
      &lt;li&gt;타이머는 매 클럭 틱 때마다 1씩 감소&lt;/li&gt;
      &lt;li&gt;타이머 값이 -(마이너스)가 되면 타이머 인터럽트 발생&lt;/li&gt;
      &lt;li&gt;CPU를 특정 프로그램이 독점하는 것으로부터 보호&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;타이머는 time sharing을 구현하기 위해 널리 이용됨&lt;/li&gt;
  &lt;li&gt;타이머는 현재 시간을 계산하기 위해서도 사용&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;7-dma-controller&quot;&gt;7. DMA Controller&lt;/h3&gt;

&lt;p&gt;메모리에 접근할 수 있는 장치는 CPU가 유일하다. 메모리는 CPU의 작업 공간이다. I/O장치나 다른 장치들이 접근 할 수 없다. 그렇다보니 1ms 마다 인터럽트가 발생한다면 CPU는 계속해서 자잘한 인터럽트를 처리해야하는 문제가 생긴다. 때문에 이를 해결하기 위해 메모리에 접근 할 수 있도록 도와주는 장치가 DMA 컨트롤러이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;빠른 입출력 장치를 메모리에 가까운 속도로 처리하기 위해 사용&lt;/li&gt;
  &lt;li&gt;CPU의 중재 없이 device controller가 device의 buffer storage의 내용을 메모리에 block 단위로 직접 전송&lt;/li&gt;
  &lt;li&gt;바이트 단위가 아니라 block 단위로 인터럽트를 발생시킴&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;8-pcprogram-counter&quot;&gt;8. PC(Program counter)&lt;/h3&gt;
&lt;p&gt;CPU의 레지스터중 하나.
pc는 다음번에 실행할 명령어의 주소를 가지고 있다.
하나의 기계어가 종료 이후의 다음 위치를 가리킨다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;인터럽트interrupt&quot;&gt;인터럽트(Interrupt)&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;현대의 운영체제는 인터럽트에 의해 구동된다.&lt;/li&gt;
  &lt;li&gt;인터럽트 당한 시점의 레지스터와 Program counter를 save 한 후 CPU의 제어를 인터럽트 처리 루틴에 넘긴다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;넓은-의미의-interrupt&quot;&gt;넓은 의미의 interrupt&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;하드웨어 인터럽트
    &lt;ul&gt;
      &lt;li&gt;하드웨어가 발생시킨 인터럽트&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;소프트웨어 인터럽트
    &lt;ul&gt;
      &lt;li&gt;Exception : 프로그램이 오류를 범한 경우&lt;/li&gt;
      &lt;li&gt;Systeme Call : 프로그램이 커널 함수를 호출하는 경우&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;인터럽트-관련-용어&quot;&gt;인터럽트 관련 용어&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;인터럽트 백터&lt;br /&gt;
해당 인터럽트 처리 루틴 주소를 가지고 있음&lt;/li&gt;
  &lt;li&gt;인터럽트 처리 루틴(=Interrupt Service Routine, 인터럽트 핸들러)&lt;br /&gt;
해당 인터럽트를 처리하는 커널 함수&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;동작&quot;&gt;동작&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;인터럽트가 발생하면 CPU는 하던 일을 멈추고 커널 내에서 해당 인터럽트의 처리를 위해 정의된 코드를 찾게된다.&lt;/li&gt;
  &lt;li&gt;운영체제는 할 일을 쉽게 찾아가기 위해 인터럽트 벡터(interrupt vector)를 가지고 있다. 인터럽트 백터란 인터럽트 종류마다 번호를 정해서 번호에 따라 처리해야 할 코드가 위치한 부분을 가리키는 자료구조를 말한다.&lt;/li&gt;
  &lt;li&gt;인터럽트 백터를 따라가면 실제 처리해야 할 코드는 인터럽트 처리 루틴(Interrupt service routine) 또는 인터럽트 핸들러(Interrupt handler)라고 불리는 다른 곳에 정의된다.&lt;/li&gt;
  &lt;li&gt;인터럽트 처리 루틴을 통해 해당되는 인터럽트 처리를 완료하고 나면 원래 수행하던 작업으로 돌아가 중단되었던 일을 계속해서 수행한다.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;시스템-콜system-call&quot;&gt;시스템 콜(System Call)&lt;/h3&gt;
&lt;p&gt;사용자 프로그램이 운영체제의 서비스를 받기 위해 커널함수(운영체제)를 호출하는 것&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;Q. 운영체제한테 CPU가 넘어가는 경우는 언제인가?&lt;/strong&gt;&lt;/p&gt;
  &lt;ul&gt;
    &lt;li&gt;인터럽트 발생(Interrupt Line 사용하는 경우)
      &lt;ul&gt;
        &lt;li&gt;하드웨어 장치들이 I/O가 인터럽트를 요청 할 때&lt;/li&gt;
        &lt;li&gt;timer 가 정해진 시간이 지난 후에 CPU에 제어권을 넘기는 경우&lt;/li&gt;
        &lt;li&gt;시스템 콜 발생시&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;Exception 발생시&lt;/li&gt;
  &lt;/ul&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;동기식-입출력과-비동기식-입출력&quot;&gt;동기식 입출력과 비동기식 입출력&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;동기식 입출력(synchronous I/O)
    &lt;ul&gt;
      &lt;li&gt;I/O 요청 후 입출력 작업이 완료된 후에야 제어가 사용자 프로그램에 넘어감&lt;/li&gt;
      &lt;li&gt;구현 방법1
        &lt;ul&gt;
          &lt;li&gt;I/O가 끝날 때까지 CPU를 낭비시킴&lt;/li&gt;
          &lt;li&gt;매시점 하나의 I/O만 일어날 수 있음&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;구현 방법2
        &lt;ul&gt;
          &lt;li&gt;I/O가 완료될 때까지 해당 프로그램에게서 CPU를 빼앗음&lt;/li&gt;
          &lt;li&gt;I/O 처리를 기다리는 줄에 그 프로그램을 줄 세움&lt;/li&gt;
          &lt;li&gt;다른 프로그램에게 CPU를 줌&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;비동기식 입출력(asynchronous I/O)
    &lt;ul&gt;
      &lt;li&gt;I/O가 시작된 후 입출력 작업이 끝나기를 기다리지 않고 제어가 사용자 프로그램에 즉시 넘어감&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;두 경우 모두 I/O 완료는 인터럽트로 알려준다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;</content><author><name>zangzangs</name></author><category term="운영체제" /><category term="os" /><summary type="html">컴퓨터 시스템 구조</summary></entry></feed>